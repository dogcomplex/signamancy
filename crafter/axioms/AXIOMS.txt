AXIOMATIC RULES:
- all equations are collections of tokens transitioning to other tokens (tokens_before => tokens_after)
- a token is text or emojis separated by whitespace
- each token represents an aspect of the global state which is changing
- for => relationships, tokens on the left are being consumed (rendered inert) and tokens on the right are being produced (rendered active)
- any token used on both sides is unchanged and acts as a catalyst (these enable conditional/if statements)
- any token can be substituted for an equivalent token (marked by <=> relationship)
- as a trivial extension of the above, tokens with quantities (e.g. ğŸ3) can be used instead of creating separate tokens for each quantity
- the purpose of this system is to be as expressive as possible without resorting to too much additional logic
- this system uses immutable rules and tokens to map out global state transitions
- please avoid any additional extensions to the basic logic beyond these axioms
- this means (for now): no multiplication, no division, no modulo, no bitwise operators, no indexing, no arrays, etc.
- many of the above can be implemented in these rules, but are generally better off remaining simple unless really needed to reduce verbosity
- in general, these axiom production rules should be seen as simple functions, consuming inputs and producing outputs

Two more tools of this system are:
- listeners: e.g. current_square(ğŸ§) move_left => left_square(ğŸ§)
  - use listeners as pointers to subsections of the global state (trivially: all tokens prefixed by the listener)
  - the above is saying "if player is in the current square and we move left, then the player is in the left square"
  - equivalently: remove the player from current square, add it to the left square
  - equivalently: current_square_player move_left => left_square_player  (but this creates new tokens instead of just using subsets)
- â— priority: if two rules are possible at the same time, use the one with the â— priority flag
  - this enables if/else logic, if-zero logic, and guarantees win/lose/error checks if possible

Special tokens:
- ğŸ¬ <=> GAME_START  # start token, never produced except by the execution logic (resets should use an intermediate token)
- ğŸ <=> GAME_END  # end token, never consumed except by the execution logic to stop execution (resets should use an intermediate token)
- âŒ› <=> STEP  # time step token, produced by the system clock event loop and passed to each grid square to enable syncronous time-based rules


# special
ğŸ¬ <=> GAME_START
âŒ› <=> STEP
ğŸ <=> GAME_END

# init
ğŸ¬ => â¹ï¸â†”ï¸64 â¹ï¸â†•ï¸64 ğŸŒ ğŸ‘£ ğŸ‘£(ğŸ§) â° ğŸ† ğŸ®âŒ›
  # start with one ğŸ† so it's non-negative when hp loss
â¹ï¸â†”ï¸ <=> grid_width
â¹ï¸â†•ï¸ <=> grid_height
ğŸŒ <=> grid origin square

# loop
â° ğŸ®âŒ› => â° âŒ› ğŸ’—âŒ› ğŸ® â²
  # time listener. Every time input action is resolved: 
    # tick time âŒ›
    # tick health check ğŸ’—âŒ›
    # create a new action ğŸ®
    # add to total steps â²
  # TODO: need to propagate âŒ› across whole grid

# listeners
ğŸ‘£ <=> target_square_listener
â¬† <=> up_listener # (e.g. square one up from player if ğŸ‘£(ğŸ§) )
â¬‡ <=> down_listener
â¬… <=> left_listener
â¡ <=> right_listener
ğŸ‘£ => ğŸ‘£ â¬† â¬‡ â¬… â¡  # given a target square, get relative listeners (default grid behavior)
ğŸ‘£(ğŸ§) => ğŸ‘£(ğŸ§) â¬†3 â¬‡3 â¬…4 â¡4  # player can see 3 up/down 4 left/right
# e.g. â¬†(ğŸŸ©) ğŸ‘£(ğŸ§Ÿâ€â™‚ï¸) # a square contains a zombie and above it is a grass square
# rules using listeners should be universal irregardless of which square is being applied ğŸ‘£
# ğŸ‘£(ğŸ§) is the prototypical example though (current square player standing in)
# â¬† â¬‡ â¬… â¡ are always relative to ğŸ‘£
# advanced:
# "two squares up from ğŸ‘£ contains water": â¬†2(ğŸŸ¦)
# "two squares up 1 right from ğŸ‘£ contains water": â¬†2â¡(ğŸŸ¦)

# game state:
â—98 ğŸ’—âŒ› => ğŸ # no health, game over
# if alive, chance of regen health over time:
â—99 ğŸ’§ âš¡ ğŸ– ğŸ’— ğŸ’—âŒ›10 => ğŸ’§ âš¡ ğŸ– ğŸ’—2 ğŸ†0.1  # every 10 turns regen health if nonempty stats
â—99 ğŸ’— ğŸ’—âŒ›10 ğŸ†0.1 => # if any empty stats, every 10 turns lose a health
â—98 â²10000 => ğŸ # timeout game over

# grid squares:
ğŸŸ© <=> grass
ğŸŸ« <=> dirt
â¬œ <=> stone
ğŸŸ¦ <=> water
ğŸŸ¥ <=> lava
ğŸŸ¨ <=> sand
â¬› <=> level_edge

# object squares:
ğŸŒ³ <=> tree
ğŸ§° <=> workbench
ğŸ¥ˆ <=> iron
ğŸ–¤ <=> coal
ğŸ”¥ <=> furnace
ğŸ’ <=> diamond

# entity squares:
ğŸ„ <=> cow
ğŸ§Ÿâ€â™‚ï¸ <=> zombie
â˜ ï¸ <=> skeleton
ğŸ¹ <=> arrow => #(any dir)
  ğŸ¹â¡ <=> arrow_facing_right
  ğŸ¹â¬† <=> arrow_facing_up
  ğŸ¹â¬‡ <=> arrow_facing_down
  ğŸ¹â¬… <=> arrow_facing_left
  ğŸ¹â¡ <=> arrow_facing_right
ğŸ§ <=> player => #(any dir)
  ğŸ§â¬† <=> player_facing_up
  ğŸ§â¬‡ <=> player_facing_down
  ğŸ§â¬… <=> player_facing_left
  ğŸ§â¡ <=> player_facing_right

# general squares: (inferred, only used for general rules)
ğŸ”² <=> walkable_square => ğŸŸ© | ğŸŸ« | ğŸŸ¨ 
ğŸ”³ <=> placeable_square => ğŸŸ© | ğŸŸ« | ğŸŸ¨ | ğŸŸ¦ | ğŸŸ¥
â <=> blocked_square => â¬œ | ğŸŸ¦ | ğŸŸ¥ | â¬›
ğŸ”„ <=> directions => â¬† | â¬‡ | â¬… | â¡
â¹ï¸ <=> any_square => ğŸŸ© | ğŸŸ« | â¬œ | ğŸŸ¦ | ğŸŸ¥ | ğŸŸ¨ | â¬› | ğŸ§° | ğŸ¥ˆ | ğŸ–¤ | ğŸ”¥ | ğŸ’ 
ğŸšº <=> entity_block => ğŸŒ³ | ğŸ„ | ğŸ§Ÿâ€â™‚ï¸ | â˜ ï¸ | ğŸ§ 
â˜‘ï¸ <=> interactive_block => ğŸšº | â¬œ | ğŸ¥ˆ | ğŸ–¤ | ğŸ’

#player inventory/status
ğŸ’— <=> health
â— ğŸ’—10 => ğŸ’—9 # max health
âš¡ <=> energy
â— âš¡10 => âš¡9 # max energy
ğŸ— <=> food
â— ğŸ—10 => ğŸ—9 # max food
ğŸ’§ <=> water
â— ğŸ’§10 => ğŸ’§9 # max water


#actions:
# todo number 0 to 16
ğŸ® => # actions:
  ğŸš« <=> no_action
  ğŸ‘ˆ <=> move_left
  ğŸ‘‰ <=> move_right
  ğŸ‘† <=> move_up
  ğŸ‘‡ <=> move_down
  ğŸ– <=> do_action
  ğŸ’¤ <=> sleep
  ğŸ¤â›° <=> place_stone
  ğŸ¤ğŸ§° <=> place_workbench
  ğŸ¤ğŸ”¥ <=> place_furnace
  ğŸ¤ğŸŒ³ <=> place_plant
  ğŸ§°â›ï¸ğŸ¤ <=> make_wood_pickaxe
  ğŸ§°â›ï¸â›° <=> make_stone_pickaxe
  ğŸ§°â›ï¸ğŸ¥ˆ <=> make_iron_pickaxe
  ğŸ§°âš”ï¸ğŸ¤ <=> make_wood_sword
  ğŸ§°âš”ï¸â›° <=> make_stone_sword
  ğŸ§°âš”ï¸ğŸ¥ˆ <=> make_iron_sword

# action requirements:
ğŸš« => ğŸ®âŒ›  # no action, do nothing
â¬†(ğŸ”²) ğŸ‘£(ğŸ§) ğŸ‘† => ğŸ®âŒ› â¬†(ğŸ”² ğŸ§) ğŸ‘£(â¬†) # flat square to move to 
â¬†(ğŸŸ¥) ğŸ‘£(ğŸ§) ğŸ‘† => ğŸ®âŒ› â¬†(ğŸŸ¥ ğŸ§) ğŸ‘£(â¬†) # can also walk into lava
  # note: also need to update player position listeners
  # and do player position change (idea: ğŸ‘£(â¬†) moves the target square up)
# <see DO actions below>
â— âš¡9 ğŸ’¤ => ğŸ®âŒ›   # sleep command does nothing (or ends) if full energy
ğŸ’¤ => âš¡ ğŸ’¤ ğŸ®âŒ›  # start sleep tick
â— ğŸ’¤ ğŸ® => âš¡ ğŸ’¤ ğŸ®âŒ›  # continue sleeping, eating player action
â¬†(ğŸ”³) ğŸ‘£(ğŸ§) â›° ğŸ¤â›° => ğŸ®âŒ› â¬†(â¬œ) ğŸ‘£(ğŸ§)   # place stone
â¬†(ğŸ”³) ğŸ‘£(ğŸ§) ğŸ¤2 ğŸ¤ğŸ§° => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§)  # place workbench
â¬†(ğŸ”³) ğŸ‘£(ğŸ§) â›°4 ğŸ¤ğŸ”¥ => ğŸ®âŒ› â¬†(ğŸ”¥) ğŸ‘£(ğŸ§)  # place furnace
â¬†(ğŸŸ©) ğŸ‘£(ğŸ§) ğŸŒ± ğŸ¤ğŸŒ± => ğŸ®âŒ› â¬†(ğŸŒ±) ğŸ‘£(ğŸ§)  # place plant
ğŸ¤ â¬†(ğŸ§°) ğŸ‘£(ğŸ§) ğŸ§°â›ï¸ğŸ¤ => ğŸ®âŒ›  â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â›ï¸ğŸ¤  # make wood pickaxe (near workbench)
ğŸ¤ â›° â¬†(ğŸ§°) ğŸ‘£(ğŸ§) ğŸ§°â›ï¸â›° => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â›ï¸â›°  # make stone pickaxe
ğŸ¤ â¬†(ğŸ§°) ğŸ‘£(ğŸ§) ğŸ§°âš”ï¸ğŸ¤ => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§) âš”ï¸ğŸ¤  # make wood sword
â›° â¬†(ğŸ§°) ğŸ‘£(ğŸ§) ğŸ§°âš”ï¸â›° => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§) âš”ï¸â›°  # make stone sword
# ... x4 dirs all above
ğŸ¤ ğŸ–¤ ğŸ¥ˆ â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â¡(ğŸ”¥) ğŸ§°âš”ï¸ğŸ¥ˆ => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â¡(ğŸ”¥) âš”ï¸ğŸ¥ˆ  # make iron sword (near workbench and furnace)
ğŸ¤ ğŸ–¤ ğŸ¥ˆ â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â¡(ğŸ”¥) ğŸ§°â›ï¸ğŸ¥ˆ => ğŸ®âŒ› â¬†(ğŸ§°) ğŸ‘£(ğŸ§) â¡(ğŸ”¥) â›ï¸ğŸ¥ˆ  # make iron pickaxe
# ... x4x3 dir combos of ğŸ§° and ğŸ”¥
# TODO: do-nothing actions if invalid reqs

# DO actions:hand
â¬†(ğŸŸ¦) ğŸ‘£(ğŸ§â¬†) ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ¦) ğŸ’§ ğŸ‘£(ğŸ§â¬†) # drink water
â¬†(ğŸŒ³) ğŸ‘£(ğŸ§â¬†) ğŸ– => ğŸ®âŒ› ğŸ¤ ğŸ‘£(ğŸ§â¬†) # chop tree
â¬†(ğŸŸ©) ğŸ‘£(ğŸ§â¬†) ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ©) ğŸŒ± ğŸ‘£(ğŸ§â¬†) # gather seedling
â¬†(ğŸ) ğŸ‘£(ğŸ§â¬†) ğŸ– => ğŸ®âŒ› â¬†(ğŸ) ğŸ—6 ğŸ‘£(ğŸ§â¬†) # eat fruit
â¬†(ğŸ„) ğŸ‘£(ğŸ§â¬†) ğŸ– => ğŸ®âŒ› ğŸ—6 ğŸ‘£(ğŸ§â¬†) # eat cow
â¬†(â¬œ) ğŸ‘£(ğŸ§â¬†) â›ï¸ğŸ¤ ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸ğŸ¤ â›° ğŸ‘£(ğŸ§â¬†) # mine stone
â¬†(â¬œ) ğŸ‘£(ğŸ§â¬†) â›ï¸â›° ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸â›° â›° ğŸ‘£(ğŸ§â¬†) # mine stone
â¬†(â¬œ) ğŸ‘£(ğŸ§â¬†) â›ï¸ğŸ¥ˆ ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸ğŸ¥ˆ â›° ğŸ‘£(ğŸ§â¬†) # mine stone
â¬†(ğŸ¥ˆ) ğŸ‘£(ğŸ§â¬†) â›ï¸â›° ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸â›° ğŸ¥ˆ ğŸ‘£(ğŸ§â¬†) # mine stone
â¬†(ğŸ¥ˆ) ğŸ‘£(ğŸ§â¬†) â›ï¸ğŸ¥ˆ ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸ğŸ¥ˆ ğŸ¥ˆ ğŸ‘£(ğŸ§â¬†) # mine stone
â¬†(ğŸ–¤) ğŸ‘£(ğŸ§â¬†) â›ï¸â›° ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸â›° ğŸ–¤ ğŸ‘£(ğŸ§â¬†) # mine coal
â¬†(ğŸ–¤) ğŸ‘£(ğŸ§â¬†) â›ï¸ğŸ¥ˆ ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸ğŸ¥ˆ ğŸ–¤ ğŸ‘£(ğŸ§â¬†) # mine coal
â¬†(ğŸ’) ğŸ‘£(ğŸ§â¬†) â›ï¸ğŸ¥ˆ ğŸ– => ğŸ®âŒ› â¬†(ğŸŸ«) â›ï¸ğŸ¥ˆ ğŸ’ ğŸ‘£(ğŸ§â¬†) # mine diamond
# ... x4 dirs

# combat:
# attacking:
â¬†(ğŸ§Ÿâ€â™‚ï¸) ğŸ‘£(ğŸ§â¬†) âš”ï¸ğŸ¤ ğŸ– => ğŸ®âŒ› â¬†(ğŸ§Ÿâ€â™‚ï¸ ğŸ§Ÿâ€â™‚ï¸ğŸ’”) ğŸ‘£(ğŸ§â¬†) âš”ï¸ğŸ¤  # hurt zombie
â¬†(ğŸ§Ÿâ€â™‚ï¸) ğŸ‘£(ğŸ§â¬†) âš”ï¸â›° ğŸ– => ğŸ®âŒ› â¬†(ğŸ§Ÿâ€â™‚ï¸ ğŸ§Ÿâ€â™‚ï¸ğŸ’”2) ğŸ‘£(ğŸ§â¬†) âš”ï¸â›°  # hurt zombie stone sword
â¬†(ğŸ§Ÿâ€â™‚ï¸) ğŸ‘£(ğŸ§â¬†) âš”ï¸ğŸ¥ˆ ğŸ– => ğŸ®âŒ› â¬†(ğŸ§Ÿâ€â™‚ï¸ ğŸ§Ÿâ€â™‚ï¸ğŸ’”3) ğŸ‘£(ğŸ§â¬†) âš”ï¸ğŸ¥ˆ  # kill zombie with iron sword
â— ğŸ§Ÿâ€â™‚ï¸ğŸ’”3 ğŸ§Ÿâ€â™‚ï¸ => # destroy zombie when it has 3 damage (#TODO ğŸ‘£(ğŸ§Ÿâ€â™‚ï¸ğŸ’”3 ğŸ§Ÿâ€â™‚ï¸) =>
â—2 ğŸ§Ÿâ€â™‚ï¸ğŸ’”4 => ğŸ§Ÿâ€â™‚ï¸ğŸ’”3 # max dmg
# ... same for skeleton, and x4 dirs


# defending:
â¬†(ğŸ§Ÿâ€â™‚ï¸) ğŸ‘£(ğŸ§) âŒ› => ğŸ’”2 â¬†(ğŸ§Ÿâ€â™‚ï¸) ğŸ‘£(ğŸ§)  # zombie attacks player
â— â¬†(ğŸ¹â¬‡) ğŸ‘£(ğŸ§) âŒ› => ğŸ’”2 ğŸ‘£(ğŸ§)  # arrow hits player
# ... x4 dirs
# lava:
ğŸ‘£(ğŸ§ ğŸŸ¥) => ğŸ‘£(ğŸ§ ğŸŸ¥) ğŸ’”9 # hp disappears in lava (instantly)
â— ğŸ’” ğŸ’— => # resolve hurt, remove hp

# entity movement:
ğŸ‘£(ğŸ¹â¡) â¡(ğŸ”²) âŒ› => â¡(ğŸ¹â¡) # arrows maintain direction
ğŸ²25 ğŸ‘£(ğŸ„) â¬†(ğŸ”²) âŒ› => ğŸ²25 â¬†(ğŸ„) # cows can move any direction, randomly
ğŸ²50 ğŸ‘£(ğŸ„) â¬‡(ğŸ”²) âŒ› => ğŸ²50 â¬‡(ğŸ„)
ğŸ²75 ğŸ‘£(ğŸ„) â¬…(ğŸ”²) âŒ› => ğŸ²75 â¬…(ğŸ„)
ğŸ²100 ğŸ‘£(ğŸ„) â¡(ğŸ”²) âŒ› => ğŸ²100 â¡(ğŸ„)
# enemies:
ğŸ‘£(ğŸ§Ÿâ€â™‚ï¸) â¡(ğŸ”²) âŒ› => â¡(ğŸ§Ÿâ€â™‚ï¸) # zombies can move any direction (TODO not random, need player position logic)
ğŸ‘£(â˜ ï¸) â¡(ğŸ”²) âŒ› => â¡(â˜ ï¸) # skeletons can move any direction
# ... x4 dirs
# fruit growth:
ğŸ² ğŸ‘£(ğŸ) âŒ› => ğŸ² ğŸ‘£(ğŸ) # no change 99% of the time (not ripe)
ğŸ²100 ğŸ‘£(ğŸ) âŒ› => ğŸ²100 ğŸ‘£(ğŸ) # grows apples 1% of the time (ripen)





# achievements:
ğŸ†ğŸ¤ <=> achievement_collect_wood
ğŸ†ğŸ§° <=> achievement_place_workbench # aka table
ğŸ†ğŸ„ <=> achievement_create_eat_cow
ğŸ†ğŸŒ± <=> achievement_collect_sapling
ğŸ†ğŸ’§ <=> achievement_collect_drink
ğŸ†â›ï¸ğŸ¤ <=> achievement_create_wood_pickaxe
ğŸ†âš”ï¸ğŸ¤ <=> achievement_create_wood_sword
ğŸ†ğŸ <=> achievement_place_plant
ğŸ†ğŸ§Ÿâ€â™‚ï¸ <=> achievement_defeat_zombie
ğŸ†â›° <=> achievement_collect_stone
ğŸ†â¬œ <=> achievement_place_stone
ğŸ†ğŸ <=> achievement_eat_plant
ğŸ†â˜ ï¸ <=> achievement_defeat_skeleton
ğŸ†â›ï¸â›° <=> achievement_create_stone_pickaxe
ğŸ†âš”ï¸â›° <=> achievement_create_stone_sword
ğŸ†ğŸ’¤ <=> achievement_wake_up
ğŸ†ğŸ”¥ <=> achievement_place_furnace
ğŸ†ğŸ–¤ <=> achievement_collect_coal
ğŸ†ğŸ¥ˆ <=> achievement_collect_iron
ğŸ†ğŸ’ <=> achievement_collect_diamond
ğŸ†â›ï¸ğŸ¥ˆ <=> achievement_create_iron_pickaxe
ğŸ†âš”ï¸ğŸ¥ˆ <=> achievement_create_iron_sword

# requirements: 
ğŸ†ğŸ¤âœ” <=> achievement_collect_wood_requirements
ğŸ†ğŸ§°âœ” <=> achievement_place_workbench_requirements
# ...

# achievements build tree:
ğŸ†ğŸ¤âœ– ğŸ†ğŸ¤âœ” => ğŸ† ğŸ†ğŸ¤
ğŸ†ğŸ¤ ğŸ†ğŸ§°âœ– ğŸ†ğŸ§°âœ” => ğŸ† ğŸ†ğŸ¤ ğŸ†ğŸ§°
ğŸ†ğŸ„âœ– ğŸ†ğŸ„âœ” => ğŸ† ğŸ†ğŸ„
ğŸ†ğŸŒ±âœ– ğŸ†ğŸŒ±âœ” => ğŸ† ğŸ†ğŸŒ±

ğŸ†ğŸ’§âœ– ğŸ†ğŸ’§âœ” => ğŸ† ğŸ†ğŸ’§
ğŸ†ğŸ§° ğŸ†â›ï¸ğŸ¤âœ– ğŸ†â›ï¸ğŸ¤âœ” => ğŸ† ğŸ†ğŸ§° ğŸ†â›ï¸ğŸ¤
ğŸ†ğŸ§° ğŸ†âš”ï¸ğŸ¤âœ– ğŸ†âš”ï¸ğŸ¤âœ” => ğŸ† ğŸ†ğŸ§° ğŸ†âš”ï¸ğŸ¤
ğŸ†ğŸŒ± ğŸ†ğŸâœ– ğŸ†ğŸâœ” => ğŸ† ğŸ†ğŸŒ± ğŸ†ğŸ

ğŸ†ğŸ§Ÿâ€â™‚ï¸âœ– ğŸ†ğŸ§Ÿâ€â™‚ï¸âœ” => ğŸ† ğŸ†ğŸ§Ÿâ€â™‚ï¸
ğŸ†â›ï¸ğŸ¤ ğŸ†â›°âœ– ğŸ†â›°âœ” => ğŸ† ğŸ†â›ï¸ğŸ¤ ğŸ†â›°
ğŸ†â›° ğŸ†â¬œâœ– ğŸ†â¬œâœ” => ğŸ† ğŸ†â›° ğŸ†â¬œ
ğŸ†ğŸ ğŸ†ğŸâœ– ğŸ†ğŸâœ” => ğŸ† ğŸ†ğŸ ğŸ†ğŸ

ğŸ†â˜ ï¸âœ– ğŸ†â˜ ï¸âœ” => ğŸ† ğŸ†â˜ ï¸
ğŸ†â›° ğŸ†â›ï¸â›°âœ– ğŸ†â›ï¸â›°âœ” => ğŸ† ğŸ†â›° ğŸ†â›ï¸â›°
ğŸ†âš”ï¸ğŸ¤ ğŸ†âš”ï¸â›°âœ– ğŸ†âš”ï¸â›°âœ” => ğŸ† ğŸ†âš”ï¸ğŸ¤ ğŸ†âš”ï¸â›°
ğŸ†ğŸ’¤âœ– ğŸ†ğŸ’¤âœ” => ğŸ† ğŸ†ğŸ’¤

ğŸ†â›° ğŸ†ğŸ”¥âœ– ğŸ†ğŸ”¥âœ” => ğŸ† ğŸ†â›° ğŸ†ğŸ”¥
ğŸ†â›ï¸ğŸ¤ ğŸ†ğŸ–¤âœ– ğŸ†ğŸ–¤âœ” => ğŸ† ğŸ†â›ï¸ğŸ¤ ğŸ†ğŸ–¤
ğŸ†â›ï¸â›° ğŸ†ğŸ¥ˆâœ– ğŸ†ğŸ¥ˆâœ” => ğŸ† ğŸ†â›ï¸â›° ğŸ†ğŸ¥ˆ

ğŸ†â›ï¸ğŸ¥ˆ ğŸ†ğŸ’âœ– ğŸ†ğŸ’âœ” => ğŸ† ğŸ†â›ï¸ğŸ¥ˆ ğŸ†ğŸ’
ğŸ†ğŸ”¥ ğŸ†ğŸ–¤ ğŸ†ğŸ¥ˆ ğŸ†â›ï¸ğŸ¥ˆâœ– ğŸ†â›ï¸ğŸ¥ˆâœ” => ğŸ† ğŸ†ğŸ”¥ ğŸ†ğŸ–¤ ğŸ†ğŸ¥ˆ ğŸ†â›ï¸ğŸ¥ˆ
ğŸ†ğŸ”¥ ğŸ†ğŸ–¤ ğŸ†ğŸ¥ˆ ğŸ†âš”ï¸ğŸ¥ˆâœ– ğŸ†âš”ï¸ğŸ¥ˆâœ” => ğŸ† ğŸ†ğŸ”¥ ğŸ†ğŸ–¤ ğŸ†ğŸ¥ˆ ğŸ†âš”ï¸ğŸ¥ˆ
# explanation: requires zero-quantity âœ– to produce, ensuring it's only done once
# i.e. flipped bit
# TODO could avoid the above âœ– âœ” stuff by putting achievement conditions (including prereqs) in the actions themselves
# but we do this all so there's just a single generation of ğŸ† counter



#TODO:
# inputs: just 64x64x3 as input image states

# spawning / despawning entities
- zombies/cows grassland, skeletons caves
- more zombies at night
- lower visibility at night

# rewards (score +-0.1 per hp, +1 per achievement)
- geometric mean of success rates

# status checks:
- see food (water, resource, enemy etc...)
- can move to target (no tools)
- can move to target with tools

# general strategy:
- hiding from enemies in enclosed spaces
- avoiding lava
- avoiding projectiles
- only fighting with weapons
- eating food
- pathfinding






=====================================================================
# above was a "perfected" human-made set of rules after analyzing the program, looking for what an eventual system might approximate

# below is a ground-up attempt at discovery (human simulated), using only input data ("64x64 images") and inference from that
# where applicable we call non-axiom programs (e.g. ocr) to get data

# Below is an attempted "blind world model building" of the following video:
# https://www.youtube.com/watch?v=2bALHna35os

ğŸ¬ => ğŸ“· â°               # start with a picture and knowledge of time
ğŸ“· <=> ğŸ“·ğŸ’»(â”) ğŸ“·âŒ¨(â”)         # split image into screen and interface (LMM, detect sections)
ğŸ“·âŒ¨(â”) => ğŸ“·âŒ¨(ğŸ’—9 ğŸ—9 ğŸ’§9 âš¡9)   # split interface into inventory tokens (OCR and LLM)
ğŸ“·ğŸ’»(â”) => â¹â†”9 â¹â†•7         # split screen into 9x7 grid  (TODO grid size from paper not inferred from screen...)
# CRITIQUE: grid inferred by fiat not from inferring screen
â¹â†”9 â¹â†•7 => â¹â†”â†•(â”) ... â¹â†”5â†•4(â”) ... â¹â†”9â†•7(â”) # use image cutter to make 63 squares, each with their own contents and position (1,1 to 9,7).  mark each as unknown
â¹ï¸ => â¹â†”â†• | â¹â†”2â†• | ... | â¹â†”9â†•7  # generalize any-square relation
â¹â†”4â†•3(â”) => â¹â†”4â†•3(ğŸ§â¬‡ ğŸŸ©)   # mark player in the center square (standing on grass).  (visual analysis LMM)
â¹(â”) => â¹(ğŸŸ©)              # mark all as having grass (visual analysis LMM)
â¹â†”8â†•(â”) => â¹â†”8â†•(ğŸŒ³)        # mark one square as tree (visual analysis LMM)
ğŸ® => ğŸ®#1 | ... | ğŸ®#17     # known actions, but let's just assume it only knows 1-17 int inputs
  ğŸ®#1 <=> ğŸš« <=> no_action   # etc...
  ğŸ®#2 <=> ğŸ‘ˆ <=> move_left
  ğŸ‘‰ <=> move_right
  ğŸ‘† <=> move_up
  ğŸ‘‡ <=> move_down
  ğŸ– <=> do_action
  ğŸ’¤ <=> sleep
  ğŸ¤â›° <=> place_stone
  ğŸ¤ğŸ§° <=> place_workbench
  ğŸ¤ğŸ”¥ <=> place_furnace
  ğŸ¤ğŸŒ³ <=> place_plant
  ğŸ§°â›ï¸ğŸ¤ <=> make_wood_pickaxe
  ğŸ§°â›ï¸â›° <=> make_stone_pickaxe
  ğŸ§°â›ï¸ğŸ¥ˆ <=> make_iron_pickaxe
  ğŸ§°âš”ï¸ğŸ¤ <=> make_wood_sword
  ğŸ§°âš”ï¸â›° <=> make_stone_sword
  ğŸ§°âš”ï¸ğŸ¥ˆ <=> make_iron_sword
â° => â° ğŸ®     # allow time to pass and a command is created
ğŸ® => ğŸ®#4    # choose action 4 (move_up, but unknown so far)
  # note: everything with ... implies it doesnt know what other parts of the state mattered, so it includes the whole state
  ğŸ®#4 â¹ï¸â†”8â†•(ğŸŒ³) â¹ï¸â†”4â†•3(ğŸ§â¬‡) ... => â¹ï¸â†”4â†•3(ğŸ§â¬†) â¹ï¸â†”8â†•2(ğŸŒ³) â¹ï¸â†”6â†•(ğŸŒ³) ...  
    # player moves up, tree moves down 
    # the grass movement isnt obvious yet
    # spawns new tree in above row
# poll LLM on previous changes: it probably guesses:
  ğŸ®#4 <=> ğŸ‘† <=> move_up
  # when asked to guess implied rules:
  â¹ï¸â†”xâ†•y(...) ğŸ®#4 => â¹ï¸â†”xâ†•y+1(...) and  # move all square contents down by 1
  â¹ï¸â†”4â†•3(ğŸ§â¬‡) ğŸ®#4 => â¹ï¸â†”4â†•3(ğŸ§â¬†)  # rotate char up (subsequent re-polls may generalize ğŸ§â¬‡ to ğŸ§) 
  ğŸ®#4 => â¹ï¸â†”xâ†•(â”) # new top row
  # it probably does not get that:
  â¹ï¸â†”xâ†•8 ğŸ®#4 => # but disappear the bottom row (or store to memory) 
# ... repeat above for more actions (up up up right right)
# then new command:
  â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸŒ³) ğŸ®#6 ... => â¹ï¸â†”4â†•3(ğŸ§â¡) ... ğŸ“·âŒ¨(ğŸ¤1)  # done via lmm / ocr of inventory
  # new action button, tree disappeared and new item in inventory
  # (may or may not guess that player must be facing tree.  but will confirm that in subsequent action presses)
  # probably guesses:
  ğŸ®#6 <=> ğŸª“ğŸŒ³ <=> chop_tree # which is wrong (just one possible action) but dont know yet
# surprise: arrow
  ğŸ®#4 => â¹ï¸â†”1â†•3(ğŸ¹â¡)  # it thinks might be tied to up action cuz it doesnt know
  ğŸ®#4 â¹ï¸â†”1â†•3(ğŸ¹â¡) => â¹ï¸â†”2â†•4(ğŸ¹â¡)
  ğŸ®#4 â¹ï¸â†”2â†•4(ğŸ¹â¡) => â¹ï¸â†”3â†•5(ğŸ¹â¡)
  ğŸ®#4 â¹ï¸â†”3â†•5(ğŸ¹â¡) => â¹ï¸â†”4â†•6(ğŸ¹â¡)
  ğŸ®#6 â¹ï¸â†”4â†•6(ğŸ¹â¡) â¹ï¸â†”1â†•6(â˜ ï¸) => â¹ï¸â†”5â†•6(ğŸ¹â¡) # surprise skeleton!
  # ask LLM: probably gets that skeleton npc appeared and can shoot arrows
  â¹ï¸â†”xâ†•y(â˜ ï¸) => â¹ï¸â†”xâ†•y(â˜ ï¸) â¹ï¸â†”x+1â†•y(ğŸ¹â¡)
  â¹ï¸â†”xâ†•y(â˜ ï¸) => â¹ï¸â†”x+1â†•y(â˜ ï¸) | â¹ï¸â†”xâ†•y+1(â˜ ï¸) | â¹ï¸â†”x-1â†•y(â˜ ï¸) | â¹ï¸â†”xâ†•y-1(â˜ ï¸) # and can move any dir
  â¹ï¸â†”xâ†•y(ğŸ¹â¡) => â¹ï¸â†”x+1â†•y(ğŸ¹â¡) # and probably gets that arrows move
  # probably gets that this is independent of the action ğŸ® used
# NOTE: timing is incorrect here so far.  e.g. how do we mark rules that require changes
  # probably need to pass ğŸ®#4 to each grid square
# small surprise: water ğŸŸ¦ and sand ğŸŸ¨
  # ...
# small surprise: stone â¬œ dirt ğŸŸ« iron ğŸ¥ˆ (ğŸŸ§) on stone
# surprise: cow ğŸ„ on grass
  # eat cow:
  â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸ„) ğŸ®#6 ... ğŸ“·âŒ¨(ğŸ’§9) => â¹ï¸â†”4â†•3(ğŸ§â¡) ğŸ“·âŒ¨(ğŸ’§8) ...  
    # confusing lol.  eating cow made you thirsty.
  ğŸ®#6 <=> ğŸ‘„ğŸ„ <=> eat_cow # likely LMM guess
  ğŸ®#6 <=> interact # likely guesses more general purpose based on previous rules
# ...
# surprise: energy down
ğŸ®#3 ğŸ“·âŒ¨(âš¡9) ... => ğŸ“·âŒ¨(âš¡8) ...
# surprise: make workbench
  ğŸ®#9 â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸŸ©) ğŸ“·âŒ¨(ğŸ¤3) ... => â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸ§°) ğŸ“·âŒ¨(ğŸ¤2) ...
  # LLM guess:
  ğŸ®#9 <=> ğŸ¤ğŸ§° <=> place_workbench
  # if asked to generalize to just the relevant tokens it thinks for the rule, probably correctly guesses 1 wood cost and facing square
# surprise: pickaxe 
  ğŸ®#12 â¹ï¸â†”4â†•3(ğŸ§â¡) ğŸ“·âŒ¨(ğŸ¤2) ... => â¹ï¸â†”4â†•3(ğŸ§â¡) ğŸ“·âŒ¨(ğŸ¤1 â›ï¸ğŸ¤)  ...
  # LLM guess:
  ğŸ®#12 <=> ğŸ§°â›ï¸ğŸ¤ <=> make_wood_pickaxe
  # probably correctly guesses 1 wood cost, may not get needs to be near workbench yet
# minor surprise: mine stone
  ğŸ®#6 â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(â¬œ) ... => â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸŸ«) ğŸ“·âŒ¨(â›°1)  ...
  # create one stone in inventory, stone wall => dirt
  # ask LLM "besides the changing state tokens, which other tokens might be relevant to this rule"
    # probably gets that pickaxe needed
# minor surprise: create stone sword ...
# minor surprise: random thirsty ...
# minor surprise: zombie
# minor surprise: stone pickaxe
# minor surprise: eat cow raises food to 9
# minor surprise: drink water raises water by 1
# minor surprise: iron mine
  # LLM may not guess it needs stone pickaxe
# minor surprise: coal
# minor surprise: arrows stop at stone
# minor surprise: place stone in dirt
# surprise: screen darken then sleep
  â¹ï¸ => â¹ï¸(ğŸ•¶) # add darkness to each square that just happens each step (lots of surprise)
    # marks new squares entirely, LMM could guess they're just darkening
  ğŸ®#7 â¹ï¸â†”4â†•3(ğŸ§) ... => â¹ï¸â†”4â†•3(ğŸ§ğŸ’¤) ğŸ“·âŒ¨(âš¡) ...
  ğŸ®#7 <=> ğŸ’¤ <=> sleep
  â¹ï¸(ğŸ•¶) => â¹ï¸ # lighten each square in dawn (each step)
# minor surprise: lava
# surprise: hp down from zombie
# surprise: hp down from arrow
# surprise: water from 1 to 0 (no consequence yet)
# surprise: kill zombie (using ğŸ®#6)
# surprise: gather sapling (from ğŸŸ©)
# surprise: plant sapling
# surprise: hp down when food is 0
  # might be hard for LLM to guess this one but it'll figure it out eventually
# minor surprise: furnace
# minor surprise: iron pickaxe
# minor surprise: kill skeleton
# minor surprise: place stone in water
# minor surprise: fruit growth (seems random)
# minor surprise: diamond
# surprise: walk in lava
  â¹ï¸â†”4â†•3(ğŸ§â¡) â¹ï¸â†”5â†•3(ğŸŸ¥) ğŸ®#6 ... ğŸ“·âŒ¨(ğŸ’—9) => â¹ï¸â†”4â†•3(ğŸ§â¡ ğŸŸ¥) ... 
  # lose all hp
  # game ends




