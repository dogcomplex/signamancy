# COMMANDS
ğŸ® <=> controls =>
  â¤´ <=> turn_left 
  â¤µ <=> turn_right
  ğŸ‘‰ <=> forward
  ğŸ¤ <=> pickup
  ğŸ– <=> drop
  ğŸ‘‹ <=> toggle
  ğŸ™Œ <=> done

# SQUARES
â¹ <=> square (any) => â¹ğŸ”² â¹ğŸ“¦ | â¹ğŸ”²  # contents can be empty

# Floor:
â¹ğŸ”² <=> square_floor (any) <=> â¹ğŸ”² â¹
  â¬› <=> normal
  ğŸŸ© <=> goal_square
  ğŸŸ§ <=> lava
  â¬œ <=> wall
  ğŸšª <=> door # any (multiple colors)

# OBJECTS/ENTITIES
â¹ğŸ“¦ <=> square_contents =>
  ğŸ”‘ <=> key # any (multiple colors)
  â­• <=> obstacle # any (multiple colors)
  ğŸ <=> box
  ğŸ¦Š <=> agent # any (multiple directions)
  
# META:
ğŸ¬ <=> GAME_START
ğŸ <=> GAME_END
ğŸ† <=> win <=> goal # distinct from goal_square, as sometimes it's not just a location
  # note, game may end without the agent actually reaching the goal
ğŸ˜¿ <=> lose
ğŸ’° <=> reward
â° <=> timer
âŒ› <=> step
âŒ›ğŸ”š <=> max_steps <=> remaining_steps

# Keys:
ğŸ”‘ <=> key =>
  ğŸ”‘ğŸŸ¥ <=> key_red
  ğŸ”‘ğŸŸ¨ <=> key_yellow
  ğŸ”‘ğŸŸ© <=> key_green
  ğŸ”‘ğŸŸ¦ <=> key_blue
  ğŸ”‘ğŸŸª <=> key_purple
  ğŸ”‘â¬œ <=> key_grey


# Doors:
ğŸšª <=> door <=> ğŸšªğŸŒˆ ğŸšªğŸ›… # a door square is defined by its color and its state
  ğŸšªğŸŒˆ <=> door_color => # abstraction
  ğŸšªğŸŸ¥ <=> door_red
  ğŸšªğŸŸ¨ <=> door_yellow
  ğŸšªğŸŸ© <=> door_green
  ğŸšªğŸŸ¦ <=> door_blue
  ğŸšªğŸŸª <=> door_purple
  ğŸšªâ¬œ <=> door_grey

ğŸšªğŸ›… <=> door_state => # abstraction
  ğŸšªğŸ”’ <=> door_locked
  ğŸšªğŸ”“ <=> door_closed # but unlocked
  ğŸšªâ¬› <=> door_open


# full door states: # ground truth descriptions
ğŸšª =>
  ğŸšªğŸ”’ğŸŸ¥ <=> door_locked_red <=> ğŸšªğŸŸ¥ ğŸšªğŸ”’
  ğŸšªğŸ”“ğŸŸ¥ <=> door_closed_red
  ğŸšªâ¬›ğŸŸ¥ <=> door_open_red
  ğŸšªğŸ”’ğŸŸ¨ <=> door_locked_yellow
  ğŸšªğŸ”“ğŸŸ¨ <=> door_closed_yellow
  ğŸšªâ¬›ğŸŸ¨ <=> door_open_yellow
  ğŸšªğŸ”’ğŸŸ© <=> door_locked_green
  ğŸšªğŸ”“ğŸŸ© <=> door_closed_green
  ğŸšªâ¬›ğŸŸ© <=> door_open_green
  ğŸšªğŸ”’ğŸŸ¦ <=> door_locked_blue
  ğŸšªğŸ”“ğŸŸ¦ <=> door_closed_blue
  ğŸšªâ¬›ğŸŸ¦ <=> door_open_blue
  ğŸšªğŸ”’ğŸŸª <=> door_locked_purple
  ğŸšªğŸ”“ğŸŸª <=> door_closed_purple
  ğŸšªâ¬›ğŸŸª <=> door_open_purple
  ğŸšªğŸ”’â¬œ <=> door_locked_grey
  ğŸšªğŸ”“â¬œ <=> door_closed_grey
  ğŸšªâ¬›â¬œ <=> door_open_grey

# Boxes:
ğŸ <=> box =>
  ğŸğŸŸ¥ <=> box_red
  ğŸğŸŸ¨ <=> box_yellow
  ğŸğŸŸ© <=> box_green
  ğŸğŸŸ¦ <=> box_blue
  ğŸğŸŸª <=> box_purple
  ğŸâ¬œ <=> box_grey

# agent states:
ğŸ¦Š => ğŸ¦ŠğŸ”„ ğŸ¦ŠğŸ“¦ | ğŸ¦ŠğŸ”„  # an agent may have a rotation and a (optional) inventory
ğŸ¦ŠğŸ”„ => # rotation abstraction
  ğŸ¦Šâ¬† <=> agent_up
  ğŸ¦Šâ¬‡ <=> agent_down
  ğŸ¦Šâ¡ <=> agent_right
  ğŸ¦Šâ¬… <=> agent_left
ğŸ¦ŠğŸ“¦ => # inventory abstraction
  ğŸ¦ŠğŸ”‘ <=> agent_carrying_key
  ğŸ¦ŠğŸ <=> agent_carrying_box

# Grid:
â¹â†” <=> grid_width
â¹â†• <=> grid_height
â¹ğŸ“ <=> grid_square_position =>
  â¹â†”â†• <=> grid_position_1_1
  â¹â†”2â†•3 <=> grid_position_2_3
  # ...
â <=> grid_square_non_walkable =>
  â¹ğŸ“¦ | â¬œ | ğŸšªğŸ”’ | ğŸšªğŸ”“  # any contents or door is locked/closed
âœ… <=> grid_square_walkable =>
  â¬› | ğŸŸ§ | ğŸŸ© | ğŸšªâ¬› 

# Relative positioning:
ğŸ‘£ <=> current_square #(execution pointer)
â¬† <=> grid_square_above_ğŸ‘£
â¬‡ <=> grid_square_below_ğŸ‘£
â¬… <=> grid_square_left_ğŸ‘£
â¡ <=> grid_square_right_ğŸ‘£
ğŸ‘£(ğŸ¦Š) <=> current_square_with_ğŸ¦Š_in_it => ğŸ‘£(â¹ğŸ”² ğŸ¦Š)
ğŸ‘£ğŸ¦Š <=> ğŸ‘£â¹ğŸ”² ğŸ‘£ğŸ¦Š  # same thing?

# ACTION LOGIC:
ğŸ¦Šâ¬† â¤´ => ğŸ¦Šâ¬…
ğŸ¦Šâ¬† â¤µ => ğŸ¦Šâ¡
ğŸ¦Šâ¬‡ â¤´ => ğŸ¦Šâ¡
ğŸ¦Šâ¬‡ â¤µ => ğŸ¦Šâ¬…
ğŸ¦Šâ¬… â¤´ => ğŸ¦Šâ¬‡
ğŸ¦Šâ¬… â¤µ => ğŸ¦Šâ¬†
ğŸ¦Šâ¡ â¤´ => ğŸ¦Šâ¬†
ğŸ¦Šâ¡ â¤µ => ğŸ¦Šâ¬‡
ğŸ‘£(ğŸ¦Šâ¬†) ğŸ‘‰ â¬†(âœ…) => â¬†(ğŸ¦Šâ¬† âœ…) # move up one grid square if walkable and facing up
ğŸ‘£(ğŸ¦Šâ¬†) ğŸ‘‰ â¬†(â) => â¬†(â) ğŸ‘£(ğŸ¦Šâ¬†) # if not walkable, stay in place
ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦0) ğŸ¤ â¬†(â¹ğŸ“¦) => ğŸ‘£(ğŸ¦Šâ¬† â¹ğŸ“¦)  # if facing an item, pickup
ğŸ‘£(ğŸ¦Šâ¬†) ğŸ¤ â¬†(â¹ğŸ“¦0) => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(â¹ğŸ“¦0)  # if nothing to pickup, do nothing
ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦) ğŸ¤ â¬†(â¹ğŸ“¦) => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(â¹ğŸ“¦) # if already holding something, do not pickup
ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦) ğŸ– â¬†(â¹ğŸ“¦) => ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦) â¬†(â¹ğŸ“¦) # cant drop to full square
ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦) ğŸ– â¬†(â¬›) => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(â¬› â¹ğŸ“¦) # drop on empty square
ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦0) ğŸ– => ğŸ‘£(ğŸ¦Šâ¬† ğŸ¦ŠğŸ“¦0)  # if not holding anything, drop does nothing
ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸ”“) ğŸ‘‹ => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªâ¬›) # open door if unlocked
ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸ”’) ğŸ‘‹ => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸ”’) # do nothing if locked
ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªâ¬›) ğŸ‘‹ => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸ”“) # close door if open
ğŸ™Œ => ğŸ # end game


# game logic
ğŸ¬ => âŒ›100 ğŸŒ ğŸ® # start with 100 steps, grid world, and controls
âŒ› => ğŸ®  # one action per step

ğŸ‘£(ğŸŸ©) => ğŸ† # win if standing on goal
ğŸ‘£(ğŸŸ§) => ğŸ˜¿ # lose if standing on lava
ğŸ† => ğŸ # end game
ğŸ˜¿ => ğŸ # end game
âŒ›0 => ğŸ # timeout ends game

# grid generation logic (TODO)
ğŸŒ

# agent sight logic (TODO)

# key/door logic (TODO)

# mission logic (TODO)
  # calling "done" logic
  # e.g. "go to the red door":
  ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸŸ¥) ğŸ™Œ => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(ğŸšªğŸŸ¥) ğŸ† # not sur if needs to be facing it
  #â€œgo to the matching object at the end of the hallwayâ€ would be tough! https://minigrid.farama.org/environments/minigrid/MemoryEnv/
  # â€œput the {move_color} {move_type} near the {target_color} {target_type}â€
  # â€œopen the red door then the blue doorâ€


# Reward equation:  1 - 0.9 * (step_count / max_steps) = reward
# axiom equivalent:
# âŒ›ğŸ”š100  # say max steps is 100
â— âŒ› ğŸ† => ğŸ† ğŸ’°0.009 # for each remaining step, get 0.9/100 reward
ğŸ† => ğŸ’°0.1 # goal reward (min reward)
# âŒ›100 ğŸ† => ğŸ’°1 # max reward
# âŒ›0 ğŸ† => ğŸ’°0.1 # min reward
# this is "taylor series expansion" of 1 - 0.9 * (step_count / max_steps) generally for any equation

# collision logic (certain environments):
ğŸ‘£(ğŸ¦Šâ¬†) ğŸ‘‰ â¬†(â­•) ğŸ’°1 => ğŸ‘£(ğŸ¦Šâ¬†) â¬†(â­•) # big reward loss if crash into obstacle  (note need to start with high positive reward ğŸ’° as written here)



# example grids:

# LAVA
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›ğŸŸ§â¬›â¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›â¬›â¬›â¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›ğŸŸ§â¬›â¬œ
â¬œğŸ¦Šâ¬›â¬›â¬›â¬›ğŸŸ§â¬›â¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›ğŸŸ§â¬›â¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›ğŸŸ§â¬›â¬œ
â¬œâ¬›â¬›â¬›â¬›â¬›ğŸŸ§ğŸŸ©â¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ

# o1 gets it in 1 shot:
# https://chatgpt.com/share/66e65ff9-1060-8003-b55d-f2bbc0fff163
# gpt4o and co are fairly bad though
# https://chatgpt.com/share/67255c71-a348-8003-b92c-3a8fd0104314

