
# (TIC TAC TOE) PIXEL-BASED ASYNC ATTEMPT: (each grid cell only knows itself and its neighbors. just defining the state machine for itself)
# init:
# imagine this as an internalized state machine of resources being churned on, with inputs and outputs in each cardinal and diagonal direction
# use â¬…( â¬…âŒ ) to denote listening to left for signals (neurotransmitters?), which trigger self-signals => ...signals
ğŸ¬ => ğŸ”³ âŒ_turn â¬… â¡ â¬† â¬‡ â†– â†— â†˜ â†™ # neighbor listeners
ğŸ”³ âŒ_turn => âŒ â­•_turn # remember these are choices.  either could be explored and flipped at any time
ğŸ”³ â­•_turn => â­• âŒ_turn
# note: listeners are transitions this cell can't control.  it can choose when to listen but not what it will hear
# depending on what it sees, these are the acceptable transitions it can react with
â¬…( ğŸš« ) => â¬…ğŸš« # empty, left signaled stop/timeout (wall)
â¬…( â¬…âŒ ) âŒ => â¬… âŒ â¬…âŒ # left signaled X_left, self is X, and keep propagating X_left
â¬…( â¬…âŒ ) â­• => â¬… â­• â¬…ğŸ¤ # left signaled X_left, self is O, and propagate tie_left (since conflict)
â¬…( â¬…â­• ) â­• => â¬… â­• â¬…â­• # left signaled O_left, self is O, and keep propagating O_left
â¬…( â¬…â­• ) âŒ => â¬… âŒ â¬…ğŸ¤ # left signaled O_left, self is X, and rebroadcast tie_left
â¬…( â¬…ğŸ¤ ) => â¬…  â¬…ğŸ¤ # left signaled tie_left, rebroadcast tie_left and tie_right (self-status cant change this)
â— â¬…( âŒğŸ‘‘ ) => âŒğŸ‘‘ ğŸ # left signaled X_win, and broadcast X_win, finish
â¬…( ğŸ¤âœ… ) => â¬…ğŸ¤âœ… # left signaled it sees a tie in every direction, so done listening to it
â— â¬…( âŒ_turn ) => â¬… âŒ_turn # left signaled X_turn, keep listening and propagate X_turn
â— â¬…( â­•_turn ) => â¬… â­•_turn # left signaled O_turn, keep listening and propagate O_turn
# â¬…() => â¬… # else keep listening
â¬…ğŸš« âŒ => âŒ â¬…âŒ # if nothing left, then X_left is true trivially
â¬…ğŸš« â­• => â­• â¬…â­•
# = repeat this for every direction 8 * 12 = 96 rules
# ====== tie checks:
â¬…ğŸš« â¬†ğŸš« â¡ğŸ¤ â¬‡ğŸ¤ â†–ğŸš« â†—ğŸš« â†˜ğŸ¤ â†™ğŸš« => ğŸ¤âœ… # top-left cell tie check
# ... 9 of these.  all can be passed to each cell, they will only qualify if they're the right type
# ====== tie check checks lol: (needs to search for confirmations that the other cells are all resolved)
â¬…ğŸš« â¬†ğŸš« â¡ğŸ¤âœ… â¬‡ğŸ¤âœ… â†–ğŸš« â†—ğŸš« â†˜ğŸ¤âœ… â†™ğŸš« => ğŸ¤ ğŸ # we see a tie in every direction AND see every other cell thinks the same, so stop processing this cell and conclude tie
# ... 9 of these. all can be passed to each cell, they will only qualify if they're the right type
# ====== win checks:
â— â¬…âŒ âŒ â¡âŒ => âŒğŸ‘‘ ğŸ
â— â¬…âŒ âŒ â¡ğŸš« => âŒğŸ‘‘ ğŸ
â— â¬…â­• â­• â¡â­• => â­•ğŸ‘‘ ğŸ
â— â¬…â­• â­• â¡ğŸš« => â­•ğŸ‘‘ ğŸ
# ...8*4 of these
# ====== GRAND TOTAL = 3 + 96 + 9 + 9 + 8*4 = 149 rules
# note that listeners could be implemented fairly trivially lol:
# - literally just prepend everything inside â¬…( â¬…âŒ ) with the leading symbol (so â¬…â¬…âŒ) and that's a cacheable rule
# - so you can just combine all inventories of each cell, just prepending contents and copying them to each other
# - or: just do that copying when they actually listen and interact.  it's just a heavy-duty cudgel way of doing it
# note: system needs to have pings and timeouts to detect if neighbor or not (ğŸš« signal)
# note the use of â— still to force greedy listening for win and turn signals.  tie signals should resolve naturally
# lol if we wanted a timeout clock:
=> â° # increment clock every set time period (system-provided, or clock listener)
â¬… â°100 => â¬…ğŸš« â°100 # at 100t, close listener (clock keeps incrementing)
# could add â°100 => â°1 to every successful listen, resetting clock too 
# CONCLUSION: should work!


# (SNAKE) PIXEL-BASED ASYNC ATTEMPT: (each grid cell only knows itself and its neighbors. just defining the state machine for itself)
# init:
# imagine this as an internalized state machine of resources being churned on, with inputs and outputs in each cardinal and diagonal direction
# use â¬…( â¬œ ) to denote listening to left for signals (neurotransmitters?), which trigger self-signals => ...signals
ğŸ¬ => â¬… â¡ â¬† â¬‡ â†– â†— â†˜ â†™ ğŸŒ # blank cell, listening for neighbors
ğŸ¬ => ğŸ ğŸ‘‰ â¬… â¡ â¬† â¬‡ â†– â†— â†˜ â†™ ğŸŒ # OR snake head cell, spawned with direction right, listening for neighbors
ğŸ¬ => ğŸ’ â¬… â¡ â¬† â¬‡ â†– â†— â†˜ â†™ ğŸŒ # OR food cell, listening for neighbors
# move snake right into empty cell (snake=1):
ğŸ ğŸ‘‰ âŒ› => # empty snake cell (length=1 scenario)
â— ğŸ2 ğŸ‘‰ âŒ› => ğŸ ğŸ‘‰ âŒ› â¬œ # fill cell
  #  == net effect: ğŸX ğŸ‘‰ âŒ› => â¬œX-1 (using priority â— to ensure ALL move)
â¬…(ğŸX ğŸ‘‰) âŒ› => â¬…ğŸX ğŸ‘‰ # damn. how to do listeners without X? need to be able to modify aka neurotransmit
# move snake right into filled cell:
â—99 ğŸ ğŸ‘‰ â¡(â¬œ) âŒ› => ğŸ’€ # hit wall, dead snake, game over
  # ğŸ â¬…(â¬œ ğŸ‘‰) âŒ› => # do nothing if snake crashes into you (rule not needed)
# move snake right into food cell:
â— ğŸ ğŸ‘‰ â¡(ğŸ’) âŒ› => â¬œ # eat food if present (higher priority than blank)
# TODO ---------------- switched to neurotransmitter syntax:
ğŸ’ â¬…(ğŸ2 ğŸ‘‰) âŒ› => ğŸ2 ğŸ‘‰ âŒ› # 
# ... repeat for all snake lengths
â— â¬œ âŒ› => ğŸ”³ # deplete filled square each tick
âŒ› => ğŸ”³99 # else empty square



# NEUROTRANSMITTER syntax (instead of listeners it's inputs and output gates)
# a listener check (presence check) can still be done without changing adjacent cell, but it requires â¡(â¬œ) => â¡(â¬œ) same on both sides
# if â¡(â¬œ) => on left side, it's taking an input (removing it from e.g. right cell)
# if => â¡(â¬œ) on right side, it's producing an output (adding it to e.g. right cell)
# if multiple cells are fighting for the same resources (both listening to same cell), then either one receiving is valid.  Use priority â— if one should take precedence
# 0,0 cell needs special time wiring for this to work
â—99 ğŸ’€ => ğŸ’€ ğŸ # game over, dead snake
â—99 ğŸ  ğŸ‘‰ âŒ› â¡(â¬œ) â¡  => ğŸ’€ â¡(â¬œ) # hit tail, dead snake, game over (no change to right cell)
â—99 ğŸ  ğŸ‘‰ âŒ› â¡(ğŸ§±) â¡  => ğŸ’€ â¡(ğŸ§±) # hit wall, dead snake, game over (no change to right cell)
â—3  ğŸ  ğŸ‘‰ âŒ› â¡(ğŸ’) â¡  => â¬œ â¡(ğŸ2 ğŸ‘‰) # eat food, snake grows and leaves tail cell
â—2  ğŸ2 ğŸ‘‰ âŒ›        â¡  => ğŸ ğŸ‘‰ âŒ› â¬œ  â¡(ğŸ) # fill current cell and move snake right (length>1, leaving cell filled)
â—   ğŸ  ğŸ‘‰ âŒ›        â¡  => â¡(ğŸ ğŸ‘‰) # move snake right (length=1, leaving cell empty)
â—98     ğŸ‘‰â¡         â¡  => â¡(ğŸ‘‰â¡ ğŸ‘‰â¬‡) # propagate move command globally (x axis)
â—98     ğŸ‘‰â¬‡           â¬‡  => ğŸ‘‰ â¬‡(ğŸ‘‰â¬‡) # propagate move command globally (y axis) 
â—97         âŒ›â¡      â¡  => â¡(âŒ›â¡ âŒ›â¬‡) # propagate time tick globally (x axis)
â—97         âŒ›â¬‡        â¬‡  => âŒ› â¬‡(âŒ›â¬‡) # propagate time tick globally (y axis)
# TODO ... repeat all above for each 4 move directions
â—   â¬œ âŒ› =>  # filled squares deplete over time (snake tail)
âŒ› =>  # and empty squares simply waste their time

# initialization:grow
# assume we have 0,0 cell access only
ğŸ¬ => ğŸ“ ğŸ® âŒ› ğŸ“(ğŸ“99 ğŸ“99) 
  # init: origin point, controls, time tick, origin width and height of grid
ğŸ® => ğŸ‘‰ ğŸ® # move options (these can change at any point.  or they might not change at all!)
ğŸ® => ğŸ‘ˆ ğŸ®
ğŸ® => ğŸ‘† ğŸ®
ğŸ® => ğŸ‘‡ ğŸ®
# SEE GENERAL GRID SOLUTION BELOW (lotta pain to get here):
# mainly: detecting and marking walls is painful.  as is establishing connections (effectively: creating new cells)
ğŸ“2 => â¡ â¬… ğŸ“2 # any width>1 unlocks right-left path lol
ğŸ“ => â¬… ğŸ§± # else endpoint (no right connection)
â—2 ğŸ“99 â¬… => ğŸ§± ğŸ“99 # if left col, cut left-connection (wall)
â— ğŸ“ â¡ => â¡(ğŸ“ ğŸ“99) # once connections established, siphon growth rightwards
# then repeat for y:
ğŸ“2 => â¬‡ â¬† ğŸ“2 # any height>1 unlocks down-up path lol
ğŸ“ => â¬† ğŸ§± # else endpoint (no down connection)
â—2 ğŸ“99 â¬† => ğŸ“99 ğŸ§± # if top row, cut up-connection (wall)
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # once connections established, siphon growth downwards

# TODO:
- add snake head and food on init
- add food as it's eaten (random?!?!)
   - produce a random x,y then check if it's empty? else repeat?    
- add win condition (all cells filled)
- question: is this simpler if cells know their position lol (this would be easy to preserve from init)




# GENERAL: ======================

# TINKERING: EQUALITY CHECK:
# ğŸ…°=ğŸ…± => âœ…
# ğŸ…°!=ğŸ…± => â

=> âœ… # default true if both empty
â— ğŸ…° ğŸ…± => # deplete pairs
ğŸ…° => â
ğŸ…± => â
â— âœ… â => â # contradiction takes precedent (absorb âœ…)
# note: destructive to ğŸ…° ğŸ…±.  use copies for this if they're needed after

# TINKERING: GREATER THAN CHECK:
# ğŸ…°>ğŸ…± => â¬†
# ğŸ…°<ğŸ…± => â¬‡

â— ğŸ…° ğŸ…± => # deplete
ğŸ…° => â¬†
ğŸ…± => â¬‡
# note: destructive to ğŸ…° ğŸ…±.  use copies for this if they're needed after

# TINKERING: RANDOM NUMBER GENERATION:
ğŸ²2 => âœ…     # produces âœ… with D2 odds (i.e. coin flip 50%) 
ğŸ²10 => âœ…    # produces âœ… with D10 odds (i.e. 1/10 10%) 
ğŸ²1 => âœ…     # produces âœ… never (false. D1) for posterity. dont use though
ğŸ²0 => âœ…     # (same as  => âœ…) produces âœ… always (true. D0)  for posterity. 
ğŸ²2 ğŸ => âœ…  # produces âœ… with D2 odds, always consumes ğŸ regardless 
ğŸ => âœ… ğŸ²2  # ...hmmmmmm produces randomness as a resource to use in subsequent recipes..?
# alternative:
ğŸ²2 ğŸ => ğŸ²3 âœ… # consumes ğŸ with D2 odds, produces âœ… with D3 odds... 
ğŸ => ğŸ²3 âœ… # always consumes, D3 odds to produce
ğŸ²2 ğŸ => âœ… # always produces, D2 odds to consume
# alternative:
ğŸ ğŸ²4=> âœ… # does the entire recipe with D4 odds, or not at all
# alternative (we probably need ingredient-level granularity for this to work):
ğŸ2ğŸ²4 ğŸŒğŸ²3 => âœ…ğŸ²5 # consumes ğŸ2 with D4 odds, consumes ğŸŒ with D3 odds (independent), produces âœ… with D5 odds (independent of costs)
# alternative: sometimes we want dependence.  e.g. probably caught a fish, but which one:
ğŸ£ => ğŸŸ%20 ğŸ %30 ğŸ¡%40  # last %10 is nothing.  no chance of 2 fish from one line
# alternative:
ğŸ£ => ğŸ²2 ğŸŸ
ğŸŸ => 2ğŸ²4 ğŸ  # blegh I hate it no
# TODO LATER

# GRID GENERATION AUTOMATA SOLUTION TINKERING/RAMBLING (saved for posterity and proof I'm dumb I guess?)

â—3 â¬‡ğŸŒ±99 â¡ğŸŒ±99 => ğŸ§± â¬‡ â¡ â¡(â¬‡ğŸŒ±99 â¡ğŸŒ±98) â¬‡(â¬‡ğŸŒ±98 â¡ğŸŒ±99) # origin corner

# â—2 â¬‡ğŸŒ±99 â¡ğŸŒ±X => ğŸ§± â¬‡ â¡ â¬… â¡(â¬‡ğŸŒ±99 â¡ğŸŒ±X-1) â¬‡(â¬‡ğŸŒ±98 â¡ğŸŒ±X) # top row, spread down first
â— â¬‡ğŸŒ±99 â¡ğŸŒ± => ğŸ§± â¬‡ â¡ â¬… â¡(â¬‡ğŸŒ±99) â¬‡(â¬‡ğŸŒ±98 â¡ğŸŒ±) # top row, spread down first
â—2 â¬‡ğŸŒ±99 â¡ğŸŒ±2 => â¬‡ğŸŒ±99 ğŸ§± â¬‡ â¡ â¬… â¡(â¬‡ğŸŒ±99 â¡ğŸŒ±) â¬‡(â¬‡ğŸŒ±98 â¡ğŸŒ±2) # top row, spread down first


# establish right connection:
â—3 â¬‡ğŸŒ±4 â¬† => â¬‡ğŸŒ±4 ğŸ§± # top row is a wall, so replace up connection
â—3 â¡ğŸŒ±4 â¬… => â¡ğŸŒ±4 ğŸ§± # left col is a wall
# if right connected already, prefer transfer of growth to right:
â—2 â¡ğŸŒ±2 â¡ â¬‡ => â¡ğŸŒ± â¡(â¡ğŸŒ±2) â¬‡(â¡ğŸŒ±2) # while there's extra growth, pass it on (favor right)
â—2 â¡ğŸŒ± â¡ â¬‡ => â¬‡(â¡ğŸŒ±2)
â—2 â¬‡ğŸŒ±2 â¡ â¬‡ => â¡(â¬‡ğŸŒ±2) â¬‡(â¬‡ğŸŒ±2)

â— ğŸŒ±2 => ğŸŒ± â¡ â¬… â¬‡ â¬† # if there's extra growth, share it
â¡ğŸŒ± => ğŸ§± â¡ â¬…  # establish a left-right channel if not present
â¬‡ğŸŒ± => ğŸ§± â¬‡ â¬†  # establish an up-down channel if not present


4,4ğŸ§± => 3,4 => 2,4 => 1,4 => 0,4
4,3 => 3,3 => 2,3 => 1,3 => 0,3
4,2 => 3,2 => 2,2 => 1,2 => 0,2
4,1 => 3,1 => 2,1 => 1,1 => 0,1
4,0 => 3,0 => 2,0 => 1,0 => 0,0

â—4 ğŸŒ±4 â¬† => â¡(ğŸŒ±4) ğŸ§± # top row is a wall, spread right along it
â—3 ğŸŒ±4 â¬… => ğŸ§± # left col is a wall (no spread by convention)
â—2 ğŸŒ± â¬‡ => â¬‡(ğŸŒ±) # gravity diffusion
â— ğŸŒ±2 => ğŸŒ± â¡ â¬… â¬‡ â¬† # if there's extra growth, share it
ğŸŒ± => ğŸ§± â¡ â¬… â¬‡ â¬† # else calcify into a wall



# GENERAL NOTES:
# general zero-check (how we we effectively check for zero-ness (it's an IF-ELSE))
ğŸ…°0 ğŸ…±3 => ğŸ’°7 # example <=
â— ğŸ…° ğŸ…±3 => ğŸ…° ğŸ’¸ # IF A > 0 do blah (and spend B condition)
ğŸ…±3 => ğŸ’°7 # ELSE A is 0 (unreachable otherwise)

# establishing a grid from origin width x,y: (down/right are arbitrary)
# NOTE: this does not merge the grid, and if it did it would be overlaying the indexes to make a larger grid
ğŸ“ => ğŸ“x ğŸ“y â¡ â¬‡ # widths and cardinal directions to pass things
# AKA ğŸ“x ğŸ“y => â¡ â¬‡ â¡(ğŸ“x-1 ğŸ“y) â¬‡(ğŸ“x ğŸ“y-1) # ALL WE WANT
â— ğŸ“2 ğŸ“2 => ğŸ“ ğŸ“ â¡ â¬‡ â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“)
ğŸ“ => â¡ â¡(ğŸ“)
ğŸ“ => â¬‡ â¬‡(ğŸ“)



5,5/R0,0/D0,0 (target 0,0/R4,5/D5,4)
=> 4,4/0,0/0,0 
=> 3,3/1,1/1,1 
=> 2,2/2,2/2,2 
=> 1,1/3,3/3,3 
=> 0,0/4,5/5,4
4,5/RR0,0/RD0,0 (target 0,0/RR3,5/RD4,4)
=> 3,4/0,0/0,0  
=> 2,3/1,1/1,1
=> 1,2/2,2/2,2
=> 0,1/3,4/4,3
=> 0,0/3,5/4,4
5,4/DR0,0/DD0,0 (target 0,0/DR4,4/DD5,3)
=> 4,3/0,0/0,0
=> 3,2/1,1/1,1
=> 2,1/2,2/2,2
=> 1,0/3,4/4,3
=> 0,0/4,4/5,3

1,5/RRRRR0,0/RRRRD0,0 (target 0,0/RRRRR0,5/RRRRD1,4)
=> 0,4/0,0/0,0
=> 0,3/0,1/0,1
=> 0,2/0,2/0,2
=> 0,1/0,3/0,3
=> 0,0/0,4/0,4 # EFFFFFF


ğŸ“ => ğŸ“x ğŸ“y â¡ â¬‡ # widths and cardinal directions to pass things
# ğŸ“x ğŸ“y => â¡ â¬‡ â¡(ğŸ“x-1 ğŸ“y) â¬‡(ğŸ“x ğŸ“y-1) # ALL WE WANT
â— ğŸ“2 ğŸ“2 => ğŸ“ ğŸ“ â¡ â¬‡ â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“)
ğŸ“ => â¡ â¡(ğŸ“)
ğŸ“ => â¬‡ â¬‡(ğŸ“)



1,5/RRRRR0,0/RRRRD0,0 (target 0,0/RRRRR0,5/RRRRD1,4)
=> 0,5/0,0/1,0
=> 0,4/0,1/1,1
=> 0,3/0,2/1,2
=> 0,2/0,3/1,3
=> 0,1/0,4/1,4
=> 0,0/0,5/1,5

# ğŸ“x ğŸ“y => â¡ â¬‡ â¡(ğŸ“x-1 ğŸ“y) â¬‡(ğŸ“x ğŸ“y-1) # ALL WE WANT

â— ğŸ“2 ğŸ“2 => ğŸ“ ğŸ“ â¡ â¬‡ â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“)
ğŸ“ => â¡ â¡(ğŸ“)
ğŸ“ => â¬‡ â¬‡(ğŸ“)

# problem: all interior cells get doubled
x,y => x-1,y => x-2,y => ... => 1,y => 0,y
x,y-1 => 2(x-1,y-1 => 2(x-2,y-1 => ... => 2(1,y-1 => 2(0,y-1
x,y-2 => x-1,y-2 => x-2,y-2 => ... => 1,y-2 => 0,y-2
...
x,1 => x-1,1 => x-2,1 => ... => 1,1 => 0,1
x,0 => x-1,0 => x-2,0 => ... => 1,0 => 0,0

# solutions: double edge cells too and then halve all? Nope: cant double cells they'll double forever.. unless...

# other problem!  either 0 or more than one connection generated when x y are even nums

# ğŸ“x ğŸ“y => â¡ â¬… â¬‡ â¬† â¡(ğŸ“x-1 ğŸ“y) â¬‡(ğŸ“x ğŸ“y-1) # ALL WE WANT

# solution: (to the connections issue)
ğŸ“ => â¡ â¬… ğŸ“ # any width unlocks right-left path lol
ğŸ“ => â¬‡ â¬† ğŸ“ # any height unlocks down-up path lol
â—2 ğŸ“2 ğŸ“2 â¡ â¬‡ => ğŸ“ ğŸ“ â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“) # once connections established, siphon growth evenly
â— ğŸ“ â¡ => â¡(ğŸ“) # then siphon growth to the right
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # and down
# should deplete growth in both directions before they can try to re-attempt connection forming

# so now once again just the 2* interior cells doubled issue

â—3 ğŸ“x â¬… => ğŸ“2x  # how bout trade left connection for 2x if leftmost col? 
â—3 ğŸ“y â¬† => ğŸ“2y # or top row
# then the usual:
ğŸ“ => â¡ â¬… ğŸ“ # any width unlocks right-left path lol
ğŸ“ => â¬‡ â¬† ğŸ“ # any height unlocks down-up path lol
â—2 ğŸ“2 ğŸ“2 â¡ â¬‡ => ğŸ“ ğŸ“ â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“) # once connections established, siphon growth evenly
â— ğŸ“ â¡ => â¡(ğŸ“) # then siphon growth to the right
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # and down
# now everything should be 2x 2y in the end.  Good enough.

# then to reduce back down to 1x 1y:
â—2 ğŸ“2 ğŸ“2 â¡ â¬‡ => â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“) # always preserve quantity, instead

# problem: still want to be able to close the right-connection at end of row
# we have no way to actually detect the end yet hmm...

# SEMIFINAL ANSWER: (TODO detect edge)
â—3 ğŸ“x â¬… => ğŸ“2x  # how bout trade left connection for 2x if leftmost col? 
â—3 ğŸ“y â¬† => ğŸ“2y # or top row
# then the usual:
ğŸ“ => â¡ â¬… ğŸ“ # any width unlocks right-left path lol
ğŸ“ => â¬‡ â¬† ğŸ“ # any height unlocks down-up path lol
â—2 ğŸ“2 ğŸ“2 â¡ â¬‡ => â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“) # once connections established, siphon growth evenly
â— ğŸ“ â¡ => â¡(ğŸ“) # then siphon growth to the right
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # and down


# FINAL ANSWER???
# last idea: (detect edge)
# then the usual:
ğŸ“2 => â¡ â¬… ğŸ“2 # any width>1 unlocks right-left path lol
ğŸ“2 => â¬‡ â¬† ğŸ“2 # any height>1 unlocks down-up path lol
ğŸ“ => â¬… # else endpoint
ğŸ“ => â¬†
# once connection established, siphon out growth:
â—3 ğŸ“x â¬… => ğŸ“2x  # if left col, cut left-connection (wall) and double
â—3 ğŸ“y â¬† => ğŸ“2y # if top row, cut up-connection (wall)
â—2 ğŸ“2 ğŸ“2 â¡ â¬‡ => â¡(ğŸ“ ğŸ“) â¬‡(ğŸ“ ğŸ“) # once connections established, siphon growth evenly
â— ğŸ“ â¡ => â¡(ğŸ“) # then siphon y-growth to the right
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # and x-growth down

# OH GOD ITS WORSE THAN THAT HE'S DEAD JIM, DEAD JIM, DEAD JIM
# IT"S NOT DOUBLING ITS SQUARING IM DUMB

x,y => x-1,y => x-2,y => ... => 1,y => 0,y
x,y-1 => 2x-1,2y-1) => (2x-2 + x-2= 3x-4),(2y-2 + y= 3y-2) => ... => (x-1)(1,y-1 => x(0,y-1
x,y-2 => x-1,y-2 => x-2,y-2 => ... => 1,y-2 => 0,y-2
...
x,1 => x-1,1 => x-2,1 => ... => 1,1 => 0,1
x,0 => x-1,0 => x-2,0 => ... => 1,0 => 0,0

# OH GOD:
4,4 3,4 2,4 1,4 0,4
4,3 6,7 7,11 7,15 6,19 .... forever??
...


# SMART ANSWER: (just do x in 1D, THEN do y for each x)
# ignore second dimension: JUST 1D X
ğŸ“2 => â¡ â¬… ğŸ“2 # any width>1 unlocks right-left path lol
ğŸ“ => â¬… # else endpoint
â—2 ğŸ“x â¬… => ğŸ“x # if left col, cut left-connection (wall)
â— ğŸ“ â¡ => â¡(ğŸ“ ğŸ“y) # once connections established, siphon growth rightwards
# then repeat for y:
ğŸ“2 => â¬‡ â¬† ğŸ“2 # any height>1 unlocks down-up path lol
ğŸ“ => â¬† # else endpoint
â—2 ğŸ“y â¬† => ğŸ“y # if top row, cut up-connection (wall)
â— ğŸ“ â¬‡ => â¬‡(ğŸ“) # once connections established, siphon growth downwards


# NOTE:
# this would be stupidly simple if we already had the connections established:
ğŸ“ â¡ => â¡(ğŸ“ ğŸ“y)
ğŸ“ â¬‡ => â¬‡(ğŸ“)
# now I feel extra dumb how obvious this is

