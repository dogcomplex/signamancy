https://www.science.org/doi/10.1126/sciadv.adm8470

Demonstrating how the same findings from this paper can emerge from simple rules
Effectively encoding spatial understanding as the result of simple rules

GLOBAL TOP DOWN ENVIRONMENT:

ğŸŸªğŸŸ¥ğŸŸ§ğŸŸ¨ğŸŸ©ğŸŸ¦ğŸŸ«â¬›â¬œğŸ”³

5x5
ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œâ¬œğŸâ¬œâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥

3x3: (lets use this since basically equivalent for most rules!  But we need to think about how the two can be distinguished)
ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œğŸâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥

View: UP DOWN LEFT RIGHT 1, no memory
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ  (possible from 6 states, but mouse dont know that)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ (3 states)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (3 states)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (3 states)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (3 states)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ # no movement (stop? ğŸ›‘)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ (3 states)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ (2 states)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ (2 states)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ (3 states)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (3 states) ğŸ›‘
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (2 states)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (2 states)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› (1 state)
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (2 states)
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (2 states)
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (3 state) ğŸ›‘
â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ (3 state)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (2 states)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (2 state)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› (1 state)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘ˆ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬œ (3 state)
â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘‰ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (3 state) ğŸ›‘
â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state) ğŸ›‘
â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘ˆ => â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state) ğŸ›‘
â¬†ğŸŸ§ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ ğŸ‘‰ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ (1 state)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘† => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state) ğŸ›‘
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘‡ => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘ˆ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬œ (1 state)
â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› ğŸ‘‰ => â¬†ğŸŸ§ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state) ğŸ›‘
â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…ğŸŸ« â¡â¬œ (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ (1 state) ğŸ›‘
â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ ğŸ‘ˆ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ (1 state) ğŸ›‘
â¬†â¬œ â¬‡ğŸŸ¦ â¬…ğŸŸ« â¡â¬œ ğŸ‘‰ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› ğŸ‘† => â¬†â¬œ â¬‡â¬œ â¬…â¬œ â¡â¬› (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› ğŸ‘‡ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› (1 state) ğŸ›‘
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› ğŸ‘ˆ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬œ (1 state)
â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› ğŸ‘‰ => â¬†â¬œ â¬‡ğŸŸ¦ â¬…â¬œ â¡â¬› (1 state) ğŸ›‘



ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œğŸâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥

VIEW: just forward, no memory.  actions turn 90 / 180 / 270, move forward
(note by convention ğŸ‘‰ is move, others are just turn. always moving "right" and vision turns)
# center
â¬œ ğŸ‘‰ => â¬œ
â¬œ ğŸ‘‰ => â¬›
â¬œ ğŸ‘‰ => ğŸŸ§
â¬œ ğŸ‘‰ => ğŸŸ«
â¬œ ğŸ‘‰ => ğŸŸ¦
# blocks:
â¬› ğŸ‘‰ => â¬› # ğŸ›‘
ğŸŸ§ ğŸ‘‰ => ğŸŸ§ # ğŸ›‘
ğŸŸ« ğŸ‘‰ => ğŸŸ« # ğŸ›‘
ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦ # ğŸ›‘
# free rotate:
â¬œ â¤´ => â¬œ # rotations all basically the same from white
â¬œ â¤´ => â¬›
â¬œ â¤´ => ğŸŸ§
â¬œ â¤´ => ğŸŸ«
â¬œ â¤´ => ğŸŸ¦
â¬œ â†” => â¬œ
â¬œ â†” => â¬›
â¬œ â†” => ğŸŸ§
â¬œ â†” => ğŸŸ«
â¬œ â†” => ğŸŸ¦
â¬œ â¤µ => â¬œ
â¬œ â¤µ => â¬›
â¬œ â¤µ => ğŸŸ§
â¬œ â¤µ => ğŸŸ«
â¬œ â¤µ => ğŸŸ¦
# corners:
â¬› â¤´ => ğŸŸ§ # nice rotation pattern showing corners:
ğŸŸ§ â¤´ => ğŸŸ« 
ğŸŸ« â¤´ => ğŸŸ¦ 
ğŸŸ¦ â¤´ => â¬› 
â¬› â¤µ => ğŸŸ¦
ğŸŸ¦ â¤µ => ğŸŸ«
ğŸŸ« â¤µ => ğŸŸ§
ğŸŸ§ â¤µ => â¬›
# ohmygodImissedthis:
â¬› â¤´ => â¬œ
ğŸŸ¦ â¤´ => â¬œ
ğŸŸ« â¤´ => â¬œ
ğŸŸ§ â¤´ => â¬œ
â¬œ â†” => â¬œ
â¬› â†” => â¬œ
ğŸŸ§ â†” => â¬œ
ğŸŸ« â†” => â¬œ
ğŸŸ¦ â†” => â¬œ
â¬› â¤µ => â¬œ
ğŸŸ§ â¤µ => â¬œ 
ğŸŸ« â¤µ => â¬œ 
ğŸŸ¦ â¤µ => â¬œ

# second-order rules / generalization pass: 
â¹ => â¬œ # all colors
â¹ => â¬›
â¹ => ğŸŸ§
â¹ => ğŸŸ«
â¹ => ğŸŸ¦
ğŸ”³ => ğŸŸ§ # define the "edge square" for simplicity
ğŸ”³ => ğŸŸ¦
ğŸ”³ => ğŸŸ«
ğŸ”³ => â¬›
â†ªï¸ => â¤´ # rotates
â†ªï¸ => â†”
â†ªï¸ => â¤µ
â¬œ ğŸ‘‰ => â¹ # all center rules
# â¬› ğŸ‘‰ => â¬› # ğŸ›‘ # I dont have a good syntax trick to say input matches output hmmm...
# ğŸŸ§ ğŸ‘‰ => ğŸŸ§ # ğŸ›‘
# ğŸŸ« ğŸ‘‰ => ğŸŸ« # ğŸ›‘
# ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦ # ğŸ›‘
##### â¹ ğŸ‘‰ => â¹ # this would be wrong.  it would absorb the ğŸ‘‰ but still enable jumping from any to any.   this should be a limiting gate
ğŸ‘‰ => # but this actually works haha!  can always do nothing.  (though note that this transition doesn't always actually work according to state.  it's just possible from *some* state that looks that way)
â¬œ â†ªï¸ => â¹ # all rotates can be easily defined though, so that's cool
â¬› â¤´ => ğŸŸ§ # corner rules stay the same I think.  no easy way here
ğŸŸ§ â¤´ => ğŸŸ« 
ğŸŸ« â¤´ => ğŸŸ¦ 
ğŸŸ¦ â¤´ => â¬› 
â¬› â¤µ => ğŸŸ¦
ğŸŸ¦ â¤µ => ğŸŸ«
ğŸŸ« â¤µ => ğŸŸ§
ğŸŸ§ â¤µ => â¬›
â¹ â†ªï¸ => â¬œ
# these could be dynamically discovered by e.g. assigning rules to â¹ and â†ªï¸, and checking each transition to see if they match
# important note: these are observed transitions but are NOT actually the rules, since some transitions are not possible from certain actual real states.

# one approach: 
# so, in order to test this thing, it should just run the model and reality in parallel. every time it finds a discrepancy, it clones the rule (making a distinction on the overlaps)
# e.g.:
â¬œ ğŸ‘‰ => â¬œ
â¬œ ğŸ‘‰ => â¬› # indicate two separate starting states, so mark em differently:
â¬œ ğŸ‘‰ => â¬œ
â¬œ' ğŸ‘‰ => â¬œ'
â¬œ <=> â¬œ' # group them temporarily


ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œğŸâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥

# another approach: all prev rules were 1-steps.  lets try applying them as 2-steps
# assuming 5x5 grid: (3x3 white squares)

# nomenclature:
# TOKENS, PRODUCTIONS/TRANSITIONS, RULES, STATE/STORE

# 2 STEP RULES: (VERBOSE BASIC OBSERVATIONS)
# lesson: dont use general rules lol.  only base observations or it gets out of hand fast
# format: start state + previous step + next action + next step verbose optional => next state
# FORWARD 2nd step: ğŸ‘‰
# edge => edge:
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§)  => ğŸŸ§
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬›) => â¬›
# center cross => edge:
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
# walls still block:
ğŸŸ§ ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§)2 ğŸ‘‰ => ğŸŸ§
ğŸŸ¦ ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦)2 ğŸ‘‰ => ğŸŸ¦
ğŸŸ« ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«)2 ğŸ‘‰ => ğŸŸ«
â¬› ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›)2 ğŸ‘‰ => â¬›
# rotate left:
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) => â¬œ
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬›) => â¬›
â¬œ â¤´ (â¬œ â¤´ => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â¤´ (â¬œ â¤´ => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â¤´ (â¬œ â¤´ => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â¤´ (â¬œ â¤´ => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
# 180 rotate:
# white is not possible!
â¬œ â†” (â¬œ â†” => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â†” (â¬œ â†” => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â†” (â¬œ â†” => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â†” (â¬œ â†” => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬›) => â¬›
â¬œ â†” (â¬œ â†” => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â†” (â¬œ â†” => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â†” (â¬œ â†” => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â†” (â¬œ â†” => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
# rotate right:
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) => â¬œ
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬›) => â¬›
â¬œ â¤µ (â¬œ â¤µ => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
â¬œ â¤µ (â¬œ â¤µ => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
â¬œ â¤µ (â¬œ â¤µ => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
â¬œ â¤µ (â¬œ â¤µ => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
# corners: (absorb)
â¬› â¤´ (â¬› â¤´ => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
ğŸŸ§ â¤´ (ğŸŸ§ â¤´ => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
ğŸŸ« â¤´ (ğŸŸ« â¤´ => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
ğŸŸ¦ â¤´ (ğŸŸ¦ â¤´ => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
â¬› â¤µ (â¬› â¤µ => ğŸŸ¦) ğŸ‘‰ (ğŸŸ¦ ğŸ‘‰ => ğŸŸ¦) => ğŸŸ¦
ğŸŸ¦ â¤µ (ğŸŸ¦ â¤µ => ğŸŸ«) ğŸ‘‰ (ğŸŸ« ğŸ‘‰ => ğŸŸ«) => ğŸŸ«
ğŸŸ« â¤µ (ğŸŸ« â¤µ => ğŸŸ§) ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
ğŸŸ§ â¤µ (ğŸŸ§ â¤µ => â¬›) ğŸ‘‰ (â¬› ğŸ‘‰ => â¬›) => â¬›
# sigh now need to repeat for rotations...
# TODO exercise for the reader.  moving on to generalized stuff!
# ... TODO also turning from edge to center


ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œğŸâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥

# 2-STEP generalized observations: (only showing the new rules)
# note these are only generated by simply combining observations.  no cleverness allowed only brute force
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ => ğŸ”³ # RULE full 2 step, it just gets absorbed
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸ”³') ğŸ‘‰ => ğŸ”³' # RULE aka center cross => edge (note ğŸ”³' must match)
ğŸ”³' ğŸ‘‰ (ğŸ”³' ğŸ‘‰ => ğŸ”³') ğŸ‘‰ => ğŸ”³' 
â¬œ â¤´ (â¬œ â¤´ => â¬œ) ğŸ‘‰ => â¹
â¬œ â¤´ (â¬œ â¤´ => ğŸ”³') ğŸ‘‰ => ğŸ”³'
â¬œ â†” (â¬œ â†” => â¬œ) ğŸ‘‰ => ğŸ”³
â¬œ â†” (â¬œ â†” => ğŸ”³') ğŸ‘‰ => ğŸ”³'
â¬œ â¤µ (â¬œ â¤µ => â¬œ) ğŸ‘‰ => â¹
â¬œ â¤µ (â¬œ â¤µ => ğŸ”³') ğŸ‘‰ => ğŸ”³'
# move/rotate then rotate
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) â¤´ => â¹
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) â†” => â¬œ
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) â¤µ => â¹
  #â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) â¤´ => â¬œ
  #â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) â¤´ => ğŸŸ« # rotates cant be generalized here
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸ”³) â†” => â¬œ
  #â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) â¤´ => â¬œ
  #â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => ğŸŸ§) â¤´ => â¬› # rotates cant be generalized here
  #ğŸŸ§ ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) â¤´ => â¬œ # same
  #ğŸŸ§ ğŸ‘‰ (ğŸŸ§ ğŸ‘‰ => ğŸŸ§) â¤´ => ğŸŸ«
ğŸ”³' ğŸ‘‰ (ğŸ”³' ğŸ‘‰ => ğŸ”³') â†” => ğŸ”³'
â¬œ â¤´ (â¬œ â¤´ => â¬œ) â¤´ => â¹
â¬œ â¤´ (â¬œ â¤´ => â¬œ) â†” => â¹
â¬œ â¤´ (â¬œ â¤´ => â¬œ) â¤µ => â¹'
â¬œ â†” (â¬œ â†” => â¬œ) â¤´ => â¹
â¬œ â†” (â¬œ â†” => â¬œ) â†” => â¬œ
â¬œ â†” (â¬œ â†” => â¬œ) â¤µ => â¹
â¬œ â¤µ (â¬œ â¤µ => â¬œ) â¤´ => â¬œ
â¬œ â¤µ (â¬œ â¤µ => â¬œ) â†” => â¹
â¬œ â¤µ (â¬œ â¤µ => â¬œ) â¤µ => â¹

# 2-STEP reduced observations (generalizing 2nd time):
â¬œ â†ªï¸' (â¬œ â†ªï¸' => ğŸ”³') ğŸ‘‰ => ğŸ”³'
# ... any more?  regardless, these can be auto-discovered using the general catch-alls and compared brute force


# 2-STEP reduced observations (drop the implied first step to be more general) 
# edge => edge, center cross => edge:
â¬œ ğŸ‘‰2 => ğŸŸ§ # these are the only possibilities with â¬œ ğŸ‘‰2
â¬œ ğŸ‘‰2 => ğŸŸ¦ 
â¬œ ğŸ‘‰2 => ğŸŸ«
â¬œ ğŸ‘‰2 => â¬›
# walls still block:
ğŸŸ§ ğŸ‘‰2 => ğŸŸ§
ğŸŸ¦ ğŸ‘‰2 => ğŸŸ¦
ğŸŸ« ğŸ‘‰2 => ğŸŸ«
â¬› ğŸ‘‰2 => â¬›
# rotate:
â¬œ â¤´ ğŸ‘‰ => â¬œ
â¬œ â¤´ ğŸ‘‰ => ğŸŸ§
â¬œ â¤´ ğŸ‘‰ => ğŸŸ¦
â¬œ â¤´ ğŸ‘‰ => ğŸŸ«
â¬œ â¤´ ğŸ‘‰ => â¬›
â¬œ â†” ğŸ‘‰ => ğŸŸ§
â¬œ â†” ğŸ‘‰ => ğŸŸ¦
â¬œ â†” ğŸ‘‰ => ğŸŸ«
â¬œ â†” ğŸ‘‰ => â¬›
â¬œ â¤µ ğŸ‘‰ => â¬œ
â¬œ â¤µ ğŸ‘‰ => ğŸŸ§
â¬œ â¤µ ğŸ‘‰ => ğŸŸ¦
â¬œ â¤µ ğŸ‘‰ => ğŸŸ«
â¬œ â¤µ ğŸ‘‰ => â¬›
# corners:
â¬› â¤´ ğŸ‘‰ => ğŸŸ§
ğŸŸ§ â¤´ ğŸ‘‰ => ğŸŸ«
ğŸŸ« â¤´ ğŸ‘‰ => ğŸŸ¦
ğŸŸ¦ â¤´ ğŸ‘‰ => â¬›

# 2-STEP reduced general observations: (only showing the new rules)
# note these dont preserve order.   they just say "if you have these two moves you can reach this with some combination"
â¬œ ğŸ‘‰2 => ğŸ”³ # OBSERVATION aka edge => edge
ğŸ”³' ğŸ‘‰2 => ğŸ”³' 
â¬œ ğŸ‘‰ â¤´ => â¹
â¬œ ğŸ‘‰ â†” => ğŸ”³
â¬œ ğŸ‘‰ â†” => â¬œ  # PROBLEM: order matters!
â¬œ ğŸ‘‰ â†” => â¹  # so it's actually more general
â¬œ ğŸ‘‰ â¤µ => â¹
ğŸ”³' ğŸ‘‰ â†” => ğŸ”³'
â¬œ â¤´2 => â¹
â¬œ â¤´ â†” => â¹
â¬œ â¤´ â¤µ => â¹
â¬œ â†”2 => â¬œ
â¬œ â†” â¤µ => â¹
â¬œ â¤µ â†” => â¹
â¬œ â¤µ2 => â¹

# SUMMARY (2-step) can discover a bunch of extra rules by brute force here
# LOOPS discoverable: (but would still take many more steps to confirm.... which is a very good strategy lol)
ğŸ”³' ğŸ‘‰ => ğŸ”³' # edges are absorbing
â¹' â†”2 <=> â¹' # turn around twice
â¹' â¤´ â¤µ <=> â¹' # turns reset
# which can then be reduced to:
â†”2 <=> # (this is a guess though, would need to be confirmed many times as it's possible the state is conditional)
â¤´ â¤µ <=> # same
â¤´2 <=> â†” # note: loops aren't just to blanks, they're just two-way relationships between any states

# 3-STEP same shit with one more step.
# just showing example format as this is too tedious
â¬œ ğŸ‘‰3 (â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) ğŸ‘‰ => ğŸŸ§) => ğŸŸ§
# ...
# 3-LOOPS discoverable:
â¤µ2 â†” <=>
â¤´2 â†” <=>
#### â¬œ ğŸ‘‰2 â†” (â¬œ ğŸ‘‰ â†” (â¬œ ğŸ‘‰ => â¹) => â¬œ)  # step, 180, step.  complex to represent this forced order hmmm
  # error not actually a loop anyway! cuz changes direction hah
ğŸ”³' ğŸ‘‰ â†”2 (ğŸ”³' ğŸ‘‰ â†” (ğŸ”³' ğŸ‘‰ => ğŸ”³') => â¹) => ğŸ”³' # absorbing wall and 2x reverse
# ... probably more but just testing out


# 4-STEP LOOPS:
â¤µ4 <=>
â¤´4 <=>


# LOOP CHECKLIST (basically inferred by 4-step stage, if rules are checked for loopiness)
# rotates are reversible: (these are second-order rules though)
â¤µ â¤´ <=> # nothing
â†”2 <=> # nothing
â¤µ2 <=> â†”
â¤µ3 <=> â¤´
â¤µ4 <=>  # nothing
â¤´2 <=> â†”
â¤´3 <=> â¤µ
â¤´4 <=>  # nothing


# GENERAL TINKERING:  ABILITIES WE'VE SHOWN:
- we know how to represent multiple steps (in an ordered way) as inputs => outputs
  - A: use the inference formula as an input (bit of a stretch of syntax but it's probably the best idea we have)
- we can do automated 1-step rule discovery easily
  - A: just track input state and output state.  base observation ground truth
- we can do automated rule generalizing (given basic proposed objects)
  - A: e.g. if given â¹ => â¬œ | â¬› | ğŸŸ§ | ğŸŸ« | ğŸŸ¦ then we can modify other rules by swapping these out
  - a general rule is only valid if (and while) it matches ALL applicable base operations.  this check is doable via algorithm
- we can invalidate rules
  - A: keep checking against observations.  If a rule maps to another rule they must be right
- we can reduce rules
  - A: same as generalizing, we can remove parts of the rule (e.g. same on both sides) and see if it's ever invalidated by observations
- we can discover loops
  - A: similarly, we can guess a loop rule and keep checking it to increase confidence
- we can do automated 2+-step rule discovery
  - A: each additional step rule takes the previous one as an input, and the output is the next step
  - this gives us ordered steps, which can be reduced from base observations down to generalized rules and guesses


# REMAINING THINGS TO DO:
- we need to demonstrate we can get the location of a grid square definitively from these rules without knowing the underlying environment
- we need to be able to do this even when the environment is identical (on edges) but wider in middle
- then just "run" this with different environments to confirm effectiveness
- then actually code it lol
- ongoing major problem: => or <=> rules for generalizations

# CLOCKS: hidden state squares
ğŸŸªğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ¨
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ«â¬œğŸâ¬œâ¬›
ğŸŸ«â¬œâ¬œâ¬œâ¬›
ğŸŸ©ğŸŸ¦ğŸŸ¦ğŸŸ¦ğŸŸ¥
====
ğŸŸªğŸ•šğŸ•›ğŸ•ğŸŸ¨
ğŸ•™ â†– â¬† â†— ğŸ•‘
ğŸ•˜ â¬…ğŸ¯â¡ ğŸ•’ 
ğŸ•— â†™ â¬‡ â†˜ ğŸ•“
ğŸŸ©ğŸ•–ğŸ••ğŸ•”ğŸŸ¥

# we can't see the states, but we know they exist:
# (even these rules dont really exist in the system, this is just a way to represent them)
ğŸŸ§ => ğŸ•š
ğŸŸ§ => ğŸ•
ğŸŸ§ => ğŸ•›
ğŸŸ« => ğŸ•™
ğŸŸ« => ğŸ•˜
ğŸŸ« => ğŸ•—
ğŸŸ¦ => ğŸ•–
ğŸŸ¦ => ğŸ••
ğŸŸ¦ => ğŸ•”
â¬› => ğŸ•‘
â¬› => ğŸ•’
â¬› => ğŸ•“
â¬œ => â†–
â¬œ => â¬…
â¬œ => â†™
â¬œ => â¬†
â¬œ => ğŸ¯
â¬œ => â¬‡
â¬œ => â†—
â¬œ => â¡
â¬œ => â†˜


# PLAN: in each state, we can see which of the outgoing edges (transitions) are possible.  Location is therefore mappable based on that
# so, we define according to the set of possible transitions which state we are in

# - corners:
# by definition, we can recognize the corner states and then measure distance from there
# NOTE: these aren't visible rules to the agent either.  
â¬› (â¬› â¤´ => ğŸŸ§) => ğŸ•‘ # says â¬› == ğŸ•‘
ğŸŸ§ (ğŸŸ§ â¤´ => ğŸŸ«) => ğŸ•š # (note: imply rule might not work here cuz no â¤´.  â¤´ â¤µ combo?)
ğŸŸ« (ğŸŸ« â¤´ => ğŸŸ¦) => ğŸ•—
ğŸŸ¦ (ğŸŸ¦ â¤´ => â¬›) => ğŸ•”
# - center:
# (this one's cheating, the agent hasnt discovered it yet)
â¬œ (â¬œ â¤´ => â¬œ) (â¬œ â¤´2 => â¬œ) (â¬œ â¤´3 => â¬œ) => 
# - corners2:
â¬› â¤´ (â¬› â¤´ => ğŸŸ§) => ğŸ• # says turn left at â¬›ğŸŸ§ corner to find ğŸŸ§ == ğŸ•
ğŸŸ§ (ğŸŸ§ â¤µ => â¬›) => ğŸ• # alt
ğŸŸ§ â¤´ (ğŸŸ§ â¤´ => ğŸŸ«) => ğŸ•™
ğŸŸ« (ğŸŸ« â¤µ => ğŸŸ§) => ğŸ•™
ğŸŸ« â¤´ (ğŸŸ« â¤´ => ğŸŸ¦) => ğŸ•–
ğŸŸ¦ (ğŸŸ¦ â¤µ => ğŸŸ«) => ğŸ•–
ğŸŸ¦ â¤´ (ğŸŸ¦ â¤´ => â¬›) => ğŸ•“
â¬› (â¬› â¤µ => ğŸŸ¦) => ğŸ•“
# - center crosshairs
â¬› â¤´2 (â¬› â¤´ => ğŸŸ§) => â¬†  # note: same problem as imply, no â¤´
ğŸŸ§ â¤´2 (ğŸŸ§ â¤´ => ğŸŸ«) => â¬…
ğŸŸ« â¤´2 (ğŸŸ« â¤´ => ğŸŸ¦) => â¬‡
ğŸŸ¦ â¤´2 (ğŸŸ¦ â¤´ => â¬›) => â¡


# exercise: all you know is the top-left corner. how do you get everything else from there?
# seed just top corner:
ğŸŸ§ â¤´4 (ğŸŸ§ â¤´4 => ğŸŸ« â¤´3) => ğŸ•š
ğŸŸ§ â¤´ (ğŸŸ§ â¤´ => ğŸŸ«) => ğŸ•™
ğŸŸ§ â¤´2 (ğŸŸ§ â¤´2 => ğŸŸ« â¤´) => â¬… # fun. need to enforce that corner is recognized in the first turn
# ğŸŸ§ â¤´2 (ğŸŸ§ â¤´ => ğŸŸ«) => â¬… # this is too ambiguous.  could be â¬… or ğŸ•™
ğŸŸ§ â¤´3 (ğŸŸ§ â¤´3 => ğŸŸ« â¤´2) => â¬†
# ğŸŸ§ â¤´2 ğŸ‘‰ (ğŸŸ§ â¤´ => ğŸŸ«) (ğŸŸ« â¤´ => â¬œ) (â¬œ ğŸ‘‰ => â¬œ) => # SHITTY:  we might have a syntax problem
  # we can say this, I guess:  "turn left at the ğŸŸ§ corner and you should see a ğŸŸ«.  Turn left at ğŸŸ« to see â¬œ.  Go straight â¬œ => â¬œ"
  # but that is super verbose, and it's all here because we can't specify the order of â¤´2 ğŸ‘‰
ğŸŸ§ â¤´2 ğŸ‘‰ (ğŸŸ§ â¤´2 ğŸ‘‰ => â¤´ ğŸ‘‰ ğŸŸ«) (ğŸŸ« â¤´ ğŸ‘‰ => ğŸ‘‰ â¬œ) (â¬œ ğŸ‘‰ => â¬œ) => â†™
  # this is more definitive, as each step has conditionals forcing the ordering.  but then we still need to build those subrules in an automated way
ğŸŸ§ â¤´2 ğŸ‘‰ (ğŸŸ§ â¤´2 ğŸ‘‰ => â¤´ ğŸ‘‰ ğŸŸ«) (ğŸŸ« â¤´ ğŸ‘‰ => ğŸ‘‰ â¬œ) => â†™ # the last rule can still be left off as it's implied (â¬œ ğŸ‘‰ => â¬œ)
  # "look for a ğŸŸ§ corner, turn left, then turn left again, then go forward"
  # relatively happy with this.
ğŸŸ§ â¤´2 ğŸ‘‰ (ğŸŸ§ â¤´2 ğŸ‘‰ (ğŸŸ§ â¤´ => ğŸŸ«) => â¤´ ğŸ‘‰ ğŸŸ«) (ğŸŸ« â¤´ ğŸ‘‰ => ğŸ‘‰ â¬œ) => â†™ # to be a stickler "it must use this corner rule"
# moving on:
# ğŸŸ§ â¤µ (ğŸŸ§ â¤µ => â¬œ) => â¬† # this doesnt work!  why?  ğŸŸ§ â¤µ => â¬œ is not unique like the corner
ğŸŸ§ â¤´ â¤µ2 (ğŸŸ§ â¤´ â¤µ2 => ğŸŸ« â¤µ2) => â¬† # need to do this instead to enforce recognizing the corner
ğŸŸ§ â¤´3 ğŸ‘‰ (ğŸŸ§ â¤´3 ğŸ‘‰ => â¤´2 ğŸ‘‰ ğŸŸ«) (ğŸŸ« â¤´2 ğŸ‘‰ => â¤´ ğŸ‘‰ â¬œ) (â¬œ â¤´ ğŸ‘‰ => â¤´ â¬œ) => ğŸ¯ # finally we got the center!
# ... rest are just carrying on these patterns and moving around

# Exercise: defining distance from a corner without knowing the moves
# in a sense, an action is just another transition, we don't need to include it as an input - the transition itself could be it:
ğŸ‘‰ => (â¬œ => â¬œ)
ğŸ‘‰ => (â¬œ => â¬›)
ğŸ‘‰ => (â¬œ => ğŸŸ§)
ğŸ‘‰ => (â¬œ => ğŸŸ«)
ğŸ‘‰ => (â¬œ => ğŸŸ¦)
# aka: ğŸ‘‰ => (â¬œ => â¹)
# blocks:
ğŸ‘‰ => (â¬› => â¬›) # ğŸ›‘
ğŸ‘‰ => (ğŸŸ§ => ğŸŸ§) # ğŸ›‘
ğŸ‘‰ => (ğŸŸ« => ğŸŸ«)# ğŸ›‘
ğŸ‘‰ => (ğŸŸ¦ => ğŸŸ¦) # ğŸ›‘
# aka: ğŸ‘‰ => (â¹' => â¹') including white => white
# free rotate:
â¤´ => (â¬œ => â¬œ) # rotations all basically the same from white
â¤´ => (â¬œ => â¬›)
â¤´ => (â¬œ => ğŸŸ§)
â¤´ => (â¬œ => ğŸŸ«)
â¤´ => (â¬œ > ğŸŸ¦)
â†” => (â¬œ => â¬œ)
â†” => (â¬œ => â¬›)
â†” => (â¬œ => ğŸŸ§)
â†” => (â¬œ => ğŸŸ«)
â†” => (â¬œ => ğŸŸ¦)
â¤µ => (â¬œ => â¬œ)
â¤µ => (â¬œ => â¬›)
â¤µ => (â¬œ => ğŸŸ§)
â¤µ => (â¬œ => ğŸŸ«)
â¤µ => (â¬œ => ğŸŸ¦)
# aka: â†ªï¸ => (â¬œ => â¹) 
# corners:
â¤´ => (â¬› => ğŸŸ§) # nice rotation pattern showing corners:
â¤´ => (ğŸŸ§ => ğŸŸ«) 
â¤´ => (ğŸŸ« => ğŸŸ¦)
â¤´ => (ğŸŸ¦ => â¬›)
â¤µ => (â¬› => ğŸŸ¦)
â¤µ => (ğŸŸ¦ => ğŸŸ«)
â¤µ => (ğŸŸ« => ğŸŸ§)
â¤µ => (ğŸŸ§ => â¬›) 
# rotations all basically the same from white
â¤´ => (â¬› => â¬œ)
â¤´ => (ğŸŸ§ => â¬œ)
â¤´ => (ğŸŸ« => â¬œ)
â¤´ => (ğŸŸ¦ => â¬œ)
â†” => (â¬› => â¬œ)
â†” => (ğŸŸ§ => â¬œ)
â†” => (ğŸŸ« => â¬œ)
â†” => (ğŸŸ¦ => â¬œ)
â¤µ => (â¬› => â¬œ)
â¤µ => (ğŸŸ§ => â¬œ)
â¤µ => (ğŸŸ« => â¬œ)
â¤µ => (ğŸŸ¦ => â¬œ)

# then e.g.:
ğŸŸ§ â¤´ => ğŸŸ§ (ğŸŸ§ => ğŸŸ«) => ğŸŸ«
# which is giving me strong lambda calculus vibes lol
# but this representation also means:
ğŸŸ§ â¤´ => ğŸŸ§ (ğŸŸ« => ğŸŸ¦) => ğŸŸ§ # maybe? or INVALID  choice: should this be invalid since (ğŸŸ« => ğŸŸ¦) not possible?  Or does that simply not trigger?
  # if invalid: it means (ğŸŸ« => ğŸŸ¦) is NOT an "implies", which is fair.  It's actually a "produces", and needs to be fulfilled in order to be true/valid.  
# other scenarios:
â¬œ â¤´ => â¬œ (â¬œ => â¬œ) => â¬œ
â¬œ â¤´ => â¬œ (â¬œ => â¬›) => â¬› # which both make sense


# GENERAL TINKERING: TRANSITION RULES ARE TOKENS ===============
# a token can be a transition rule, because all tokens ARE transition rules
â¤µ => (ğŸŸ§ => â¬›) # + other options
    â¤µ => (â¬œ => â¬›)
    â¤µ => (â¬œ => ğŸŸ§)
    ...
ğŸŸ§ <=> (ğŸŸ§ => ğŸŸ§) # only rule (Identity)
# in this way, pretty much any token can be represented in the pathway of transitions from the ğŸ¬ starting token
# and similarly, distance from the ğŸ finish token
# this is in line with a poset from category theory, where the system is just an ordered chains which are all connected by splits and merges between the start and finish


# SPACE of all accessible state transitions (with a single move or rotate)
# center
â¬œ => â¬œ
â¬œ => â¬›
â¬œ => ğŸŸ§
â¬œ => ğŸŸ«
â¬œ => ğŸŸ¦
# corners:
â¬› => ğŸŸ§ # nice rotation pattern showing corners:
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬› 
â¬› => ğŸŸ¦
ğŸŸ¦ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ§ => â¬›
# rotations back to center
â¬› => â¬œ
ğŸŸ§ => â¬œ
ğŸŸ« => â¬œ
ğŸŸ¦ => â¬œ
# blocks: (all identities but we should still include them)
â¬› => â¬› # since we A) never know when they're not identities
ğŸŸ§ => ğŸŸ§ # and B) not all squares have identities for all moves
ğŸŸ« => ğŸŸ«
ğŸŸ¦ => ğŸŸ¦
# ====
# generalized:
â¬œ => â¹
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬› 
â¬› => ğŸŸ¦
ğŸŸ¦ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ§ => â¬›
ğŸ”³ => â¬œ
ğŸ”³' => ğŸ”³'
# negative space:
â¬› => ğŸŸ«
ğŸŸ§ => ğŸŸ¦
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›
# (the only not-allowed rules lol. cant reach opposite wall in one move)

# SPACE OF ğŸ‘‰: 
â¬œ => â¬œ
â¬œ => â¬›
â¬œ => ğŸŸ§
â¬œ => ğŸŸ«
â¬œ => ğŸŸ¦
â¬› => â¬›
ğŸŸ§ => ğŸŸ§
ğŸŸ« => ğŸŸ«
ğŸŸ¦ => ğŸŸ¦
# generalized:
â¬œ => ğŸ”³
â¹' => â¹' 

# SPACE OF â¤´:
â¬œ => â¬œ
â¬œ => â¬›
â¬œ => ğŸŸ§
â¬œ => ğŸŸ«
â¬œ => ğŸŸ¦
â¬› => â¬œ
ğŸŸ§ => â¬œ
ğŸŸ« => â¬œ
ğŸŸ¦ => â¬œ
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›
# generalized:
â¬œ => â¹
â¹ => â¬œ
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›


# SPACE OF â†”:
â¬œ => â¬œ
â¬œ => â¬›
â¬œ => ğŸŸ§
â¬œ => ğŸŸ«
â¬œ => ğŸŸ¦
â¬› => â¬œ
ğŸŸ§ => â¬œ
ğŸŸ« => â¬œ
ğŸŸ¦ => â¬œ
# generalized:
â¬œ => â¹
â¹ => â¬œ

# SPACE OF â¤µ:
â¬œ => â¬œ
â¬œ => â¬›
â¬œ => ğŸŸ§
â¬œ => ğŸŸ«
â¬œ => ğŸŸ¦
â¬› => â¬œ
ğŸŸ§ => â¬œ
ğŸŸ« => â¬œ
ğŸŸ¦ => â¬œ
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›
# generalized:
â¬œ => â¹
â¹ => â¬œ
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›


# SPACE OF ğŸ‘‰2:
â¬œ => ğŸ”³ # strictly WILL run into edge (and/or absorb)
ğŸ”³' => ğŸ”³'

# SPACE OF â¤´2: == SPACE OF â†”
â¬œ => â¹
â¹ => â¬œ
# loses the corner values cuz it either comes or ends in white always

# SPACE OF â†”2:
â¬œ => â¬œ
â¬› => â¬›
ğŸŸ§ => ğŸŸ§
ğŸŸ« => ğŸŸ«
ğŸŸ¦ => ğŸŸ¦
# general:
â¹' => â¹'

# SPACE OF â¤µ2: == SPACE OF â†”
â¬œ => â¹
â¹ => â¬œ
# ditto for corners

# SPACE OF [ğŸ‘‰,â¤´] (ordered):
â¬œ => â¹
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›

# SPACE OF [â¤´,ğŸ‘‰] (ordered):
â¬œ => â¹
â¬› => ğŸŸ§ # note it is possible to go left from center then to edge
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›
ğŸ”³ => â¬œ (rightmost wall start)

# SPACE OF ğŸ‘‰ â¤´ (either order):
â¬œ => â¹
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›
ğŸ”³ => â¬œ


# SPACE OF [ğŸ‘‰,â†”] (ordered):
â¬œ => ğŸ”³ => â¬œ
â¬œ => â¬œ => â¹
â¬› => â¬› => â¬œ
ğŸŸ§ => ğŸŸ§ => â¬œ
ğŸŸ« => ğŸŸ« => â¬œ
ğŸŸ¦ => ğŸŸ¦ => â¬œ
# generalized:
â¬œ => â¹
â¹ => â¬œ

# SPACE OF [â†”,ğŸ‘‰] (ordered):
â¬œ => â¹' => â¹'
â¹ => â¬œ => ğŸ”³
â¹ => â¬œ => â¬œ
# generalized
â¹ => â¹'

# SPACE OF ğŸ‘‰ â†” (either order):
â¹ => â¹'

# SPACE OF [ğŸ‘‰,â¤µ] (skipping right stuff)
â¬œ => â¹
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›

# SPACE OF [â¤µ,ğŸ‘‰] (skipping right stuff)
â¬œ => â¹
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›
ğŸ”³ => â¬œ # left corner of wall

# SPACE OF â¤µ ğŸ‘‰ unordered
â¬œ => â¹
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›
ğŸ”³ => â¬œ

# SPACE OF [â¤´,â†”] (ordered):
â¬œ => â¹ => â¬œ
â¹ => â¬œ => â¹
â¬› => ğŸŸ§ => â¬œ
ğŸŸ§ => ğŸŸ« => â¬œ
ğŸŸ« => ğŸŸ¦ => â¬œ
ğŸŸ¦ => â¬› => â¬œ
# generalized:
â¹ => â¹'

# SPACE OF [â†”,â¤´] (ordered):
â¬œ => â¹ => â¬œ
â¬œ => â¹ => â¹'
â¹ => â¬œ => â¹'
# generalized:
â¹ => â¹'

# SPACE OF â¤´ â†” (either order):
â¹ => â¹'

# SPACE OF [â¤´,â¤µ] (ordered):
# SPACE OF [â¤µ,â¤´] (ordered):
# SPACE OF â¤µ â¤´ (either order):
â¬œ => â¹
â¹ => â¬œ


# SPACE OF ğŸ‘‰3:
â¬œ => ğŸ”³ # strictly WILL run into edge (and absorb)
ğŸ”³' => ğŸ”³'

# SPACE OF â¤´3: == SPACE OF â¤µ
â¬œ => â¹
â¹ => â¬œ
â¬› => ğŸŸ¦
ğŸŸ§ => ğŸŸ«
ğŸŸ« => ğŸŸ§
ğŸŸ¦ => â¬›

# SPACE OF â†”3: == SPACE OF â†”
â¬œ => â¹
â¹ => â¬œ

# SPACE OF â¤µ3: == SPACE OF â¤´
â¬œ => â¹
â¹ => â¬œ
â¬› => ğŸŸ§
ğŸŸ§ => ğŸŸ« 
ğŸŸ« => ğŸŸ¦ 
ğŸŸ¦ => â¬›


# SPACE OF [ğŸ‘‰,ğŸ‘‰,â¤´]:
# ... you get it!




# GENERAL TINKERING: MULTI STEP RULES =============================================
# Multi-step rules formatting experiments: ("instancing")
# method 1: all tokens needed, plus the previous 2-step rule: (only 1 step ever at a time, but preserves sequence)
â¬œ ğŸ‘‰3 (â¬œ ğŸ‘‰2 (â¬œ ğŸ‘‰ => â¬œ) => ğŸ”³) => ğŸ”³ # 
# method 2: show each step separately: (but doesnt preserve sequence...) (n-1 steps, since last step is innate to formulas)
â¬œ ğŸ‘‰3 (â¬œ ğŸ‘‰ => â¬œ) (â¬œ ğŸ‘‰ => â¹) => ğŸ”³ # 
# method 3: change the arrow syntax... (ewww.  would rather have rules be their own thing)
â¬œ ğŸ‘‰3 =(â¬œ ğŸ‘‰ => â¬œ),(â¬œ ğŸ‘‰ => â¹),(â¬œ ğŸ‘‰ => â¹)=> ğŸ”³ #
# method 4: all tokens are functions: (verbose but just to think about it:)
(â¬œ=>â¬œ) (ğŸ‘‰3=>ğŸ‘‰3) (â¬œ=>â¬œ ğŸ‘‰=>ğŸ‘‰ => â¬œ=>â¬œ) (â¬œ=>â¬œ ğŸ‘‰=>ğŸ‘‰ => â¹=>â¹) => ğŸ”³=>ğŸ”³ # 
# method 5: shorthand: ehhh, just one extra token
â¬œ ğŸ‘‰3 â¬œğŸ‘‰â¬œ â¬œğŸ‘‰â¹=> ğŸ”³ # shorthand
# method 6: 3 transitions (show all basically)
â¬œ ğŸ‘‰3 (â¬œ ğŸ‘‰ => â¬œ) (â¬œ ğŸ‘‰ => â¹) (â¬œ ğŸ‘‰ => â¹) => ğŸ”³ 
# method 7: instancing: trivial implication (self-referential rule) (this is the most general form)
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¬œ) => â¬œ 
    # to be fair, this says "the rule (â¬œ ğŸ‘‰ => â¬œ) is valid and you have â¬œ ğŸ‘‰.  So therefore you can produce â¬œ"
    # I think with 1-rules the (â¬œ ğŸ‘‰ => â¬œ) part can always be implied (it's itself!)
    # but that's probably not always the case with e.g. general rules
# method 8: general rules trivial implication (instance of a general rule)
â¬œ ğŸ‘‰ (â¬œ ğŸ‘‰ => â¹) => â¬œ # this is a specific instance of the general rule (â¬œ ğŸ‘‰ => â¹) being applied
    # which is the same as â¬œ ğŸ‘‰ => â¬œ since it's true either way
    # BUT - if there were multiple paths from â¬œ ğŸ‘‰ possible then (â¬œ ğŸ‘‰ => â¹) would enforce a particular path 
# conclusion:  probably method 1. it preserves order.  method 2 could work when order doesnt matter though (it's more general/flat)
    # shorthand works but just not needed much
    # probably dont use method 3 (arrow syntax)


