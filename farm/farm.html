<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <title>FARM</title>
  <style>
    body {
      overflow: hidden;
      margin: 0;
      background: #160016;
      color: #fff;
    }
  </style>
  <!-- Import Babel for JSX transformation -->
  <script src='https://unpkg.com/@babel/standalone/babel.min.js'></script>
  <!-- Import React -->
  <script src='https://unpkg.com/react@17/umd/react.development.js'></script>
  <!-- Import React DOM -->
  <script src='https://unpkg.com/react-dom@17/umd/react-dom.development.js'></script>
  <!-- Import D3 -->
  <script src='https://d3js.org/d3.v6.min.js'></script>

</head>

<body translate='no'>
  <script type='text/babel'>
    
    /* TODO
    verify against:
    https://github.com/lightvector/KataGo/blob/master/docs/GraphSearch.md


    def perform_one_playout(node):
        if is_game_over(node):
            node.U = get_utility_of_game_outcome(node.game_state)
        else if node.N == 0:  # New node not yet visited
            node.U = get_utility_from_neural_net(node.game_state)
        else:
            action = select_action_according_to_puct(node)
            if action not in node.children_and_edge_visits:
                new_game_state = node.game_state.play(action)
                if new_game_state.hash in nodes_by_hash:
                    child = nodes_by_hash[new_game_state.hash]
                    node.children_and_edge_visits[action] = (child,0)
                else:
                    new_node = Node(N=0,Q=0,game_state=new_game_state)
                    node.children_and_edge_visits[action] = (new_node,0)
                    nodes_by_hash[new_game_state.hash] = new_node
            (child,edge_visits) = node.children_and_edge_visits[action]
            perform_one_playout(child)
            node.children_and_edge_visits[action] = (child,edge_visits+1)

        children_and_edge_visits = node.children_and_edge_visits.values()

        node.N = 1 + sum(edge_visits for (_,edge_visits) in children_and_edge_visits)
        node.Q = (1/node.N) * (
            node.U +
            sum(child.Q * edge_visits for (child,edge_visits) in children_and_edge_visits)
        )
        return
    */

    const { useState, useEffect, useRef } = React;

    const defaultState = {}
    let recipesCsv = ''

    // gives a random number based on Normal distribution or Gaussian distribution, using english statistics
    function randomNormal(mean, std) {
        let u = 0,
            v = 0;
        while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        num = num / 10.0 + 0.5; // Translate to 0 -> 1
        if (num > 1 || num < 0) return randomNormal(mean, std); // resample between 0 and 1 if out of range
        return num * std + mean;
    }

    function uniqBy(a, key) {
        var seen = {};
        return a.filter(function(item) {
            var k = key(item);
            return seen.hasOwnProperty(k) ? false : (seen[k] = true);
        })
    }

    function filterZeros(o) {
        return Object.keys(o).filter((k) => o[k] > 0).reduce((r, k) => (r[k] = o[k], r), {});
    }


    // MAIN
    const inventory = {
        'ðŸ’«': 1 // Start
    }
    const recipes = {
        ID_Start: 'ðŸ’« => ðŸ’«'
    }
    const emoji_indexed_recipes = {
        'ðŸ’«': {inputs: [], outputs: []}
    }
    const recipe_history = []
    const growing_inventory = {}
    const root_node = 'ID_Start'
    let checkpoint_rewards = {
        'âœ…1ï¸âƒ£': 1000, 
        'âœ…2ï¸âƒ£': 2500,
        'âœ…3ï¸âƒ£': 5000,
        'âœ…4ï¸âƒ£': 10000,
        'âœ…5ï¸âƒ£': 20000,
        'âœ…6ï¸âƒ£': 40000,
        'âœ…7ï¸âƒ£': 80000,
        'âœ…8ï¸âƒ£': 160000,
        'âœ…9ï¸âƒ£': 320000,
        'âœ…ðŸ”Ÿ': 640000,
        'âœ…ðŸ”Ÿ1ï¸âƒ£': 1280000,
        'âœ…ðŸ”Ÿ2ï¸âƒ£': 2560000,
        'âœ…ðŸ”Ÿ3ï¸âƒ£': 5120000,
        'âœ…ðŸ”Ÿ4ï¸âƒ£': 10240000,
        'âœ…ðŸ”Ÿ5ï¸âƒ£': 20480000,
    }
    const win_target = 'âœ…3ï¸âƒ£'
    const target_reward = 20000
    const target_reward_multiplier = 3
    const failure_penalty = 1000
    const iterations = 10
    const exploration_factor = .1 // You can adjust this value to fine-tune the balance between exploration and exploitation
    const recipe_factor = 10 // reflects how much we want to prioritize recipes that havent been explored yet
    const depth_factor = 0.01 // reflects reward for how deep we are in the tree
    const random_factor = 0.001 // reflects how much we want to prioritize random choices
    
    let success = false

    let all_nodes = {}
    let duplicate_nodes = 0

    let recipe_scores = {} // TODO no idea where this should be instantiated

    /*
    Roll Sell options once per day
        - for each sell recipe, roll
    Roll Buy options once per day + 1-10 quantity

    special case for ðŸŒž
        - for each recipe that has all other things, add 1 ðŸŒž per day
        - means we gotta keep a tally... unless time is weird this way and actually does it automatically...
    special rule for %.01
    special rule for % 
    special rule for X
    special case for payday and feat day 2 and 7


    PROBLEMS:
    buy/sell doesn't quite work with fresh rerolls.  needs cached per day? (i.e. solved by making ðŸ›’ like ðŸŒž)
    everything else can be rerolled on click
    feats increasing shop stock don't add (can only hard replace) - means we have no + mechanism
    - duplicate feats shouldnt be possible

    STRATEGIES:
    - important for it to know what possible recipes there are, and which there arent (e.g. hold item in case it's useful later, or sell immediately)
       - realism vs cheating
    

    */

    /*
    parse_ingredients: takes a recipe string and returns the parsed (and randomly-rolled) ingredients list
    Inputs: recipe (string), inventory (string => float)
    */
    const parse_ingredients = (ingredients, inventory) => {
        let roll = Math.random() * 100
        const changes = {}
        const ingredients2 = ingredients.trim().split(' ')
        const ingredients_with_chance = ingredients2.filter((ingredient) => ingredient.includes('%')).length
        ingredients2.forEach((ingredient) => {
            let [in2, chance] = ingredient.trim().split('%')
            // cast chance to decimal
            if (ingredient.trim().indexOf('%') === -1)
                chance = 100
            else
                chance = chance ? parseFloat(chance) : 100.0/ingredients_with_chance
            
            let quantity = 1
            let emoji
            //const emojiRegex = new RegExp(/[\u{1f300}-\u{1f5ff}\u{1f900}-\u{1f9ff}\u{1f600}-\u{1f64f}\u{1f680}-\u{1f6ff}\u{2600}-\u{26ff}\u{2700}-\u{27bf}\u{1f1e6}-\u{1f1ff}\u{1f191}-\u{1f251}\u{1f004}\u{1f0cf}\u{1f170}-\u{1f171}\u{1f17e}-\u{1f17f}\u{1f18e}\u{3030}\u{2b50}\u{2b55}\u{2934}-\u{2935}\u{2b05}-\u{2b07}\u{2b1b}-\u{2b1c}\u{3297}\u{3299}\u{303d}\u{00a9}\u{00ae}\u{2122}\u{23f3}\u{24c2}\u{23e9}-\u{23ef}\u{25b6}\u{23f8}-\u{23fa}]/ug)
            const regex =  /^((\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]|â›°ï¸|ðŸ™†â€â™‚ï¸|0ï¸âƒ£|1ï¸âƒ£|2ï¸âƒ£|3ï¸âƒ£|4ï¸âƒ£|5ï¸âƒ£|6ï¸âƒ£|7ï¸âƒ£|8ï¸âƒ£|9ï¸âƒ£|ðŸ”Ÿ)+)([\.\dX\-\Ïƒ]*)$/
            // console.log(in2, emoji, quantity, chance, roll, in2.match(regex))
            if (!regex.test(in2)) {
                console.log(ingredients, in2, emoji, quantity, chance, roll, in2.match(regex))
                throw 'Parse error'
            }
            const match = in2.match(regex).filter((x) => x.trim())
            emoji = match[1]
            if (match[3] === 'X') // X = ALL AVAILABLE
                quantity = inventory[emoji] || 0
            else if (match[3] && (match[3].indexOf('-') > -1 || match[3].indexOf('Ïƒ') > -1)) { // MIN-MAX
                let min, max, mean, sd, stats;
                if (match[3] && match[3].split('-').length === 3) {  // MIN-MEANÏƒSD-MAX
                    [min, stats, max] = match[3].split('-');               
                    [mean, sd] = stats.split('Ïƒ').map((x) => parseFloat(x.trim()));
                } else if (match[3] && match[3].split('-').length === 2) { // MIN-MAX
                    [min, max] = match[3].split('-')
                    mean = (parseFloat(min) + parseFloat(max)) / 2
                } else { // MEANÏƒSD
                    [mean, sd] = stats.split('Ïƒ').map((x) => parseFloat(x.trim()))
                }
                min = min || 0
                
                // console.log(parseFloat(min), parseFloat(max), match[3], match[3].split('-'))

                // GENERATE RANDOMLY
                if (max === undefined && sd !== undefined)
                    quantity = Math.max(min, randomNormal(mean, sd))
                else if (max !== undefined && sd !== undefined)
                    quantity = Math.min(Math.max(min, randomNormal(mean, sd)), max)
                else if (max === undefined && sd === undefined) {
                    console.log(in2, emoji, quantity, chance, roll, in2.match(regex))
                    throw 'Parse error'
                } else
                    quantity = Math.floor(Math.random() * (parseFloat(max) - parseFloat(min) + 1)) + parseFloat(min)

            } else if (match[3]) // NORMAL RAW QUANTITY
                quantity = parseFloat(match[3])
            // ELSE QUANTITY = 1
            
            if (!emoji) {
                console.log(in2, emoji, quantity, chance, roll, in2.match(regex))
                throw 'Parse error'
            }
            if (inventory[emoji] === undefined)
                inventory[emoji] = 0
            if (chance === 100 || roll < chance && roll > 0)
                changes[emoji] = quantity
            else
                changes[emoji] = 0
            if (chance < 100)
                roll -= chance
                    
        })
        return changes
    }



    /*
    parse_recipe: takes a recipe string and returns an object with inputs and outputs
    Inputs: recipe (string), inventory (string => float)
    */
    const parse_recipe = (recipe, inventory) => {
        const [inputs, outputs] = recipe.trim().split('=>')
        const parsed = {
            inputs: parse_ingredients(inputs, inventory),
            outputs: parse_ingredients(outputs, inventory)
        }
        return parsed
    }

    /*
    has_ingredients: takes a recipe object and returns true if the inventory has all the ingredients
    Inputs: ingredients (string => float), inventory (string => float)
    */
    const has_ingredients = (ingredients, inventory) => {
        for (const ingredient in ingredients) {
            if (ingredient !== 'ðŸŒž' && inventory[ingredient] < ingredients[ingredient])
                return false
        }
        return true
    }

    /*
    parse_recipes: takes a csv string and returns an object with all the recipes
    Inputs: csv (string), recipes (string => string), emoji_indexed_recipes [string => [{recipe}]], inventory (string => float)
    */


    const parse_recipes = async (csv, recipes, emoji_indexed_recipes, inventory) => {
        if (!csv)
            return
        const rows = csv.split('\n')
        rows.shift() // remove header
        // foreach row:
        rows.forEach((row) => {
            if (row === '') // skip empty lines
                return
            const [id, recipe] = row.split(',')
            if (!id || !recipe)
                return // skip badly formatted lines
            recipes[id] = recipe.trim()
            const result = parse_recipe(recipe, inventory)
            //if (id === 'ID_Shop_Stock')
            //    console.log(row, result)
            Object.keys(result.inputs).forEach((ingredient) => {
                if (!emoji_indexed_recipes[ingredient])
                    emoji_indexed_recipes[ingredient] = {inputs:[], outputs:[]}
                emoji_indexed_recipes[ingredient].inputs.push({
                    ID: id,
                    Recipe: recipe.trim(),
                })
            })
            Object.keys(result.outputs).forEach((ingredient) => {
                if (!emoji_indexed_recipes[ingredient])
                    emoji_indexed_recipes[ingredient] = {inputs:[], outputs:[]}
                emoji_indexed_recipes[ingredient].outputs.push({
                    ID: id,
                    Recipe: recipe.trim(),
                })
            })
        })
    }


    /*
    transact_recipe: takes a recipe object and returns true if the inventory has all the ingredients
    Inputs: id (string), recipe (string), inventory (string => float), growing_inventory {string => float}, recipe_history [string => {parsed_recipe}]
    */
    const transact_recipe = (id, recipe, inventory, growing_inventory, recipe_history) => {
        const result = parse_recipe(recipe, inventory)
        // console.log(result, has_ingredients(result.inputs, inventory))
        if (!has_ingredients(result.inputs, inventory))
            return false
        if (recipe_history)
            recipe_history.push({ ID: id, Recipe: recipe, Parsed: result })

        const grow_recipe = (Object.keys(result.inputs).filter((ingredient) => ingredient === 'ðŸŒž').length > 0)
        for (const ingredient in result.inputs) {
            // sun recipes need time to grow
            if (grow_recipe) {
                Object.keys(result.outputs).forEach((ingredient) => {
                    if (!growing_inventory[ingredient])
                        growing_inventory[ingredient] = 0
                    growing_inventory[ingredient] += result.outputs[ingredient]
                })
            }
            if (ingredient !== 'ðŸŒž')
                inventory[ingredient] -= result.inputs[ingredient]
        }
        if (Object.keys(result.outputs).filter((ingredient) => ingredient === 'ðŸŒž').length > 0) // generated sun!
            grow_recipes(growing_inventory, inventory)
        
        if (!grow_recipe)
            for (const ingredient in result.outputs)
                if (ingredient !== 'ðŸŒž')
                    inventory[ingredient] += result.outputs[ingredient]
        
        return true
    }

    /*
    grow_recipes: takes a recipe object and returns true if the inventory has all the ingredients
    Inputs: growing_inventory {string => float}, inventory (string => float)
    */
    const grow_recipes = (growing_inventory, inventory) => {
        if (Object.keys(growing_inventory).length === 0)
            return false
        Object.keys(growing_inventory).forEach((ingredient) => {
            inventory[ingredient] += growing_inventory[ingredient]
        })
        growing_inventory = {}
        return true
    }

    const initialize = async (recipes, emoji_indexed_recipes, inventory) => {
        await parse_recipes(recipesCsv, recipes, emoji_indexed_recipes, inventory)
    }

    // MONTE CARLO TREE SEARCH
    class Node {
        /*
        Each Node is defined by the current Inventory + Growing Recipes AFTER it has been simulated
        Each Edge(Child) is a Recipe
        */
        constructor(state, parent = undefined) {
            this.state = {
                target_recipe: state.target_recipe ? state.target_recipe : undefined,
                inventory: state.inventory ? state.inventory : Object.assign({}, inventory),
                growing_inventory: state.growing_inventory ? state.growing_inventory : Object.assign({}, growing_inventory),
                recipe_history: state.recipe_history ? state.recipe_history : recipe_history.slice(),
                // TODO hate these, but fix later:
                inventory_before: state.inventory_before ? state.inventory_before : Object.assign({}, inventory),
                growing_inventory_before: state.growing_inventory ? state.growing_inventory : Object.assign({}, growing_inventory),
                recipe_history_before: state.recipe_history ? state.recipe_history : recipe_history.slice()
            };
            this.depth = parent === undefined ? 0 : parent.depth + 1
            this.parent = parent // originating parent
            this.parents = parent ? [parent] : [] // TODO uids?
            this.parent_paths = parent ? [[parent, this.target_recipe]] : []
            this.children = []
            this.visits = 0
            this.rewards = 0
            this.expanded = false
            this.terminal = false
            this.simulated = false
        }

        uid(hash = true) {
            // target recipe is NOT part of this because a node uid is only ever called after it has been simulated
            if (!this.simulated)
                return undefined

            let uid = ''
            // uid = this.expanded ? '' : 'X '
            uid += this.state.target_recipe.ID + ' ' + this.state.target_recipe.Recipe + ': '
            uid += Object.keys(this.state.inventory)
            .filter((ingredient) => this.state.inventory[ingredient] !== undefined && this.state.inventory[ingredient] > 0)
            .map((ingredient) => ingredient + this.state.inventory[ingredient])
            .join(' ')
            uid += ' growing: '
            uid += Object.keys(this.state.growing_inventory)
            .filter((ingredient) => this.state.growing_inventory[ingredient] !== undefined && this.state.growing_inventory[ingredient] > 0)
            .map((ingredient) => ingredient + this.state.growing_inventory[ingredient])
            .join(' ')

            // hash the uid
            if (hash) {
                uid = uid.split('').reduce((a,b)=>{a=((a<<5)-a)+b.charCodeAt(0);return a&a},0)
            }
            return uid
        }

        // DEPRECATED
        serialize() {
            const puid = this.parent ? this.parent.uid() : undefined
            let serialized = JSON.stringify([puid, this.depth, this.visits, this.rewards, this.expanded, this.terminal, this.children.map((child) => child.uid()),
                this.state.target_recipe,
                filterZeros(this.state.inventory),
                filterZeros(this.state.growing_inventory),
                this.state.recipe_history
            ])
            // console.log(serialized)
            return serialized
        }

        // DEPRECATED
        deserialize(serialized) {
            let [parent_uid, depth, visits, rewards, expanded, terminal, children, target_recipe, inventory, growing_inventory, recipe_history] = JSON.parse(serialized)
            this.depth = depth
            this.visits = visits
            this.rewards = rewards
            this.expanded = expanded
            this.terminal = terminal
            this.parent = parent_uid // UID
            this.children = children // UIDS
            this.state.target_recipe = target_recipe
            this.state.inventory = inventory
            this.state.growing_inventory = growing_inventory
            this.state.recipe_history = recipe_history
            return parent_uid
        }

        isTerminal() {
            // check if the state of the node is a terminal state
            // this will depend on the game you are implementing

            if (this.isWin())
                this.terminal = true
            if (this.expanded && this.children.length === 0)
                this.terminal = true
            return this.terminal
        }

        isWin() {
            if (this.state.inventory[win_target] > 0)
                return true
            return false
        }
    
        // MONTE CARLO TREE SEARCH
        // DEPRECATED
        get UCB1() {
            if (this.visits === 0) return Number.MAX_SAFE_INTEGER;
            return (
                this.rewards / this.visits +
                Math.sqrt(2 * Math.log(this.parent.visits) / this.visits) // TODO parents
            );
        }

        get UCT() {
            const recipe_score = recipe_scores[this.state.target_recipe.ID]
            const action_score = recipe_score?.count ? recipe_score.average : Number.MAX_SAFE_INTEGER/2 // reward new recipes
            const parents_visits = this.parents?.reduce((sum, parent) => sum + parent.visits, 0) || 0
            if (this.visits === 0)
                return exploration_factor * 0 + recipe_factor * action_score + depth_factor * this.depth + random_factor * Math.random()
            return (
                this.rewards / this.visits +
                recipe_factor * action_score +
                depth_factor * this.depth +
                random_factor * Math.random() +
                exploration_factor * Math.sqrt(2 * Math.log( parents_visits) / this.visits)
            )
        }

        select(best_fit = false) {
            // select the child node with the highest value, tiebreaking randomly
            const sorted = this.children.sort((a, b) => {
                return b.UCT - a.UCT // NOTE: this gets reversed easily!!!!

                // deprecated:
                if (!best_fit && a.visits === 0 && b.visits !== 0) return -1 // TODO this -1 doesn't seem right uhhh
                if (!best_fit && a.visits !== 0 && b.visits === 0) return 1

                if (a.visits === 0 && b.visits === 0) return 0
                if (a.UCT > b.UCT) return -1;
                if (a.UCT < b.UCT) return 1;
                return 0;
            });
            // if (!best_fit) // random this based on exploration factor?
            //   return this.children[Math.floor(Math.random() * this.children.length)]
            
            return this.children[0]
        }
        
        simulate() {
            // simulate the game from the current state and return the resulting reward
            if (this.simulated) {
                this.state.inventory = Object.assign({}, this.state.inventory_before)
                this.state.growing_inventory = Object.assign({}, this.state.growing_inventory_before)
                this.state.recipe_history = this.state.recipe_history_before ? this.state.recipe_history_before.slice() : []
            } else {
                if (this.parent) {
                    this.state.inventory = Object.assign({}, this.parent.state.inventory)
                    this.state.growing_inventory = Object.assign({}, this.parent.state.growing_inventory)
                    this.state.recipe_history = this.parent.state.recipe_history ? this.parent.state.recipe_history.slice() : []
                    // TODO ew:
                    this.state.inventory_before = Object.assign({}, this.parent.state.inventory)
                    this.state.growing_inventory_before = Object.assign({}, this.parent.state.growing_inventory)
                    this.state.recipe_history_before = this.parent.state.recipe_history ? this.parent.state.recipe_history.slice() : []
                } else {
                    this.state.inventory = Object.assign({}, inventory)
                    this.state.growing_inventory = Object.assign({}, growing_inventory)
                    this.state.recipe_history = []
                    // TODO ew:
                    this.state.inventory_before = Object.assign({}, inventory)
                    this.state.growing_inventory_before = Object.assign({}, growing_inventory)
                    this.state.recipe_history_before = []
                }
            }
            
            const prev_gold = this.state.inventory['ðŸ’°'] || 0
            const prev_inventory = Object.assign({}, this.state.inventory)
            const success = transact_recipe(this.state.target_recipe.ID, this.state.target_recipe.Recipe, this.state.inventory, this.state.growing_inventory, this.state.recipe_history)
            if (!success) {
                console.log(this.state.target_recipe, this.state, prev_gold, this, pretty_print_inventory(prev_inventory))
                throw 'Weird, that should have worked'
            }
                    
            const new_gold = this.state.inventory['ðŸ’°'] || 0
            const gold_change = new_gold - prev_gold
            //if (gold_change !== 0)
            //    console.log(prev_gold, new_gold, gold_change, this.state.target_recipe.ID, this.state.target_recipe.Recipe)
            
            this.simulated = true
            return gold_change // + Math.log(this.depth) // TODO NOOOOOO fucking idea why rewards are getting flipped negative
        }


        expand() {
            // expand the node by adding a new child representing a new state in the game
            // this will depend on the game you are implementing
            // you may need to generate all possible child nodes and add them to the children array


            this.children = []

            // GET EDGES
            const valid_child_recipes =
                Object.keys(this.state.inventory)
                .filter((ingredient) => this.state.inventory[ingredient] > 0  && emoji_indexed_recipes[ingredient] !== undefined)
                .map((ingredient) => emoji_indexed_recipes[ingredient].inputs)
                .map((recipes_list) => recipes_list.filter((recipe) => has_ingredients(parse_recipe(recipe.Recipe, this.state.inventory).inputs, this.state.inventory)))
                .filter((recipes_list) => recipes_list.length > 0)
            const unique_valid_child_recipes = uniqBy(valid_child_recipes.flat(), (item) => item.ID)
            // console.log(this.state, valid_child_recipes, unique_valid_child_recipes)

            if (this.children.length === 0) {
                unique_valid_child_recipes.forEach((recipe) => {
                    // console.log(ingredient, emoji_indexed_recipes[ingredient].inputs)
                    
                    //if (recipe.ID === 'ID_Shop_Stock')
                        //console.log(2222, recipe.ID, recipe)
                    // barebones node, becaue it's not made real til it's simulated()
                    const child = new Node({
                        target_recipe: recipe,
                    }, this)

                    this.children.push(child)
                })
            } else {
                throw 'No longer possible?'
                unique_valid_child_recipes.forEach((recipe) => {
                    const child = this.children.find((child) => child.state.target_recipe.ID === recipe.ID)
                    if (!child) {
                        const new_child = new Node({
                            target_recipe: recipe,
                            inventory: Object.assign({}, this.state.inventory), 
                            growing_inventory: Object.assign({}, this.state.growing_inventory),
                            recipe_history:  this.state.recipe_history ? this.state.recipe_history.slice() : [],
                        }, this)
                        this.children.push(new_child)
                    } else {
                        // console.log('DUPLICATE CHILD NDOE: ', child, recipe)
                    }
                })
            }

            if (this.children.length !== unique_valid_child_recipes.length) {
                console.log(this, valid_child_recipes, unique_valid_child_recipes)
                throw 'Weird, we should have the same number of children as unique recipes'
            }
            // console.log(this, valid_child_recipes, unique_valid_child_recipes)
            this.expanded = true
            return this
        }

        backpropagate(reward) {
            // update the node's statistics with the given reward
            this.visits++
            this.rewards += reward
            if (this.state.target_recipe?.ID) {
                const recipe_score = recipe_scores[this.state.target_recipe.ID] || { average: 0, sum: 0, count: 0 }
                recipe_score.sum += this.rewards / this.visits // averaged reward
                recipe_score.count++
                recipe_score.average = recipe_score.sum / recipe_score.count
                recipe_scores[this.state.target_recipe.ID] = recipe_score
            } else {
                console.log('NO TARGET RECIPE', this) // impossible error??
            }
            // propagate the update to each parent node
            this.parents?.forEach((parent) => parent.backpropagate(this.rewards / this.visits)) // pass back average of all visits
        }

        save() {
            return this
            const uid = this.uid()
            if (uid === undefined)
                throw 'Weird, this node should have a uid by now'
            if (all_nodes[uid]) {

                // set all parents to use all_nodes[uid] instead of this
                this.parents.forEach((parent) => 
                    parent.children.filter((child) => child.uid() !== uid).concat(all_nodes[uid])
                )
                this.parent_paths.forEach((parent_path) => {
                    parent_path[0].children.filter((child) => child.uid() !== uid).concat(all_nodes[uid])
                })
                // merge this parents with all_nodes[uid] parents, removing duplicates
                all_nodes[uid].parents = uniqBy(this.parents.concat(all_nodes[uid].parents), (item) => item.uid())
                // diff parents same recipe ok
                all_nodes[uid].parent_paths = uniqBy(this.parent_paths.concat(all_nodes[uid].parent_paths), (item) => item[0].uid() + ' ' + item[1])
                // children should be the same for this and all_nodes[uid], so use all_nodes[uid] children
                return all_nodes[uid]
            } else
                all_nodes[uid] = this
            // this.children.forEach((child) => child.save())
            return this
        }
    }

    function reachedCheckpoint(node, checkpoints) {
        Object.keys(checkpoints).forEach((checkpoint) => {
            if (node.state.inventory[checkpoint] > 0)
                return checkpoint
        })
        return false
    }

    function MCTS(root, iterations) {
        let wins = 0
        let losses = 0
        for (let i = 0; i < iterations; i++) {
            let node = root;
            let checkpoints = {...checkpoints}
            if (!node)
                console.log('NO NODE', root)

            while(true) {
                let reward
                reward = node.simulate()
                // @@@@@@@@@@@@TODO: problem here when re-simulating same node with different inventories different parents
                node = node.save()
                const expanded = node.expanded
                node = node.expand()
                const checkpoint = reachedCheckpoint(node, checkpoints)
                if (checkpoint) {
                    reward += checkpoints[checkpoint] * target_reward_multiplier
                    checkpoints = checkpoints.filter((c) => c !== checkpoint)
                }
                if (node.isTerminal()) {
                    if (node.isWin()) {
                        reward += node.state.inventory['ðŸ’°'] ? node.state.inventory['ðŸ’°'] + target_reward : target_reward // bonus for reaching the target
                        success = true
                        wins += 1
                        console.log('WE FUCKIN DID IT REDDIT')
                    } else {
                        if (node.children.length === 0)
                            reward += node.state.inventory['ðŸ’°'] ? node.state.inventory['ðŸ’°'] - failure_penalty : -failure_penalty
                        if (node.state.inventory['â¹'] > 0) {
                            console.log('DEAD END', node)
                            throw 'There should be moves left'
                        }
                        console.log('DEAD END', node)
                        losses += 1
                    }
                    node.backpropagate(reward)
                    break // restart from root when terminal state reached
                } else
                    node.backpropagate(reward)
                if (!node.expanded)
                    throw 'Should be expanded by now'
                
                const selected = node.select()
                selected.parent = node
                selected.depth = node.depth + 1
                node = selected  
            }
            console.log(Object.keys(all_nodes).length, node.depth, recipe_scores, node, all_nodes)
            pretty_print_inventory({ ...node.state.inventory, 'ðŸ”„': i, 'ðŸ‘‘': wins, 'ðŸ’€': losses }, node.state.growing_inventory)
        }
        // print:
        // print_best_path(root)

        // root.save()
        // console.log('ALL NODES: ', Object.keys(all_nodes).length, duplicate_nodes, all_nodes)

        return root;
    }

    const print_best_path =  (root) => {
        let node = root
        while(node.expanded && node.children.length > 0) {
            node = node.select(true) // best fit
            const choices = []
            node.children.forEach((choice) => choices.push({ depth: choice.depth, visits: choice.visits, rewards: choice.rewards, recipe: choice.state.target_recipe }))
            console.log('BEST PATH: ', node.depth, node.visits, node.rewards, node.UCB1, node.state.inventory['ðŸ’°'], node, node.state.target_recipe, node.state.recipe_history, node.state.inventory, node.state.growing_inventory, choices)

            pretty_print_inventory(node.state.inventory, node.state.growing_inventory)
        }
    }
    

    const serialize_nodes = (nodes) => {
        const serialized_nodes = {}
        Object.keys(nodes).forEach((key) => {
            const node = nodes[key]
            serialized_nodes[key] = node.serialize()
        })
        return serialized_nodes
    }

    const deserialize_nodes = (serialized_nodes) => {
        const nodes = {}
        Object.keys(serialized_nodes).forEach((key) => {
            const serialized_node = serialized_nodes[key]
            const node = new Node()
            node.deserialize(serialized_node)
            nodes[key] = node
            if (!node.parent) {
                root = node
            }
        })
        Object.keys(nodes).forEach((key) => {
            const node = nodes[key]
            if (node.parent)
                node.parent = nodes[node.parent]
            node.children = node.children.map((child) => nodes[child])
        })
        return nodes
    }



    let last_saved_file_code = 0
    let paused = false

    const save_to_file = (data, filename) => {
        const blob = new Blob([data], {type: 'application/json'})
        const a = document.createElement('a')
        a.href = URL.createObjectURL(blob)
        a.download = filename
        a.click()
    }


    const load_controls = async () => {
        await initialize(recipes, emoji_indexed_recipes, inventory)

        console.log(Object.keys(inventory).length, inventory)
        console.log(Object.keys(recipes).length, recipes)
        console.log(Object.keys(emoji_indexed_recipes).length, emoji_indexed_recipes)
        console.log(recipe_history.length, recipe_history)

        // create pretty list of links
        const links = document.createElement('div')
        links.style = 'display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;'
        document.body.appendChild(links)

        // create LOAD RECIPES CSV link
        const load_recipes_csv_link = document.createElement('a')
        load_recipes_csv_link.href = '#'
        load_recipes_csv_link.innerText = 'LOAD RECIPES CSV'
        links.appendChild(load_recipes_csv_link)
        load_recipes_csv_link.onclick = async () => {
            const file = document.createElement('input')
            file.type = 'file'
            file.onchange = async (e) => {
                const file = e.target.files[0]
                recipesCsv = await file.text()
                console.log('LOADED filelength', recipesCsv.length)
                await initialize(recipes, emoji_indexed_recipes, inventory)
                console.log('LOADED', Object.keys(emoji_indexed_recipes).length, emoji_indexed_recipes)
            }
            file.click()
        }

        // create NEW RUN link
        const new_link = document.createElement('a')
        new_link.href = '#'
        new_link.innerText = 'NEW RUN'
        links.appendChild(new_link)
        new_link.onclick = async () => {
            console.log('NEW')
            paused = false
            all_nodes = {}
            recipe_scores = {}
            const root = new Node({
                target_recipe: {
                    ID: 'ID_Start',
                    Recipe: recipes['ID_Start']
                },
                inventory: Object.assign({}, inventory),
                growing_inventory: Object.assign({}, inventory),
                recipe_history: recipe_history.slice()
            })
            const loop = async () => {
                if (paused) {
                    console.log('PAUSE RECOGNIZED')
                    return
                }
                MCTS(root, iterations)
                const data = JSON.stringify(serialize_nodes(all_nodes))
                console.log(Object.keys(all_nodes).length, data.length)
                // save_to_file(data, 'mcts_'+ ++last_saved_file_code +'.json')
                console.log('Ready')
                if (success) {
                    console.log('SUCCESS')
                    return
                }
                setTimeout(loop, 0)
            }
            loop()
            
        }

        // create SAVE link
        const save_link = document.createElement('a')
        save_link.href = '#'
        save_link.innerText = 'SAVE'
        links.appendChild(save_link)
        save_link.onclick = async () => {
            const serialized = JSON.stringify(serialize_nodes(all_nodes))
            save_to_file(serialized, 'mcts_'+ ++last_saved_file_code +'.json')
        }

        // create LOAD SAVE link
        const load_link = document.createElement('a')
        load_link.href = '#'
        load_link.innerText = 'LOAD SAVE'
        links.appendChild(load_link)
        load_link.onclick = async () => {
            const file = document.createElement('input')
            file.type = 'file'
            file.onchange = async (e) => {
                const file = e.target.files[0]
                const text = await file.text()
                const serialized_nodes = JSON.parse(text)
                all_nodes = deserialize_nodes(serialized_nodes)
                // TODO load recipe saves too
                console.log('LOADED', Object.keys(all_nodes).length)
            }
            file.click()
        }

        // create START link
        const start_link = document.createElement('a')
        start_link.href = '#'
        start_link.innerText = 'START'
        links.appendChild(start_link)
        start_link.onclick = async () => {
            paused = false
            const root = Object.keys(all_nodes).filter(key => all_nodes[key].parent === undefined)[0]
            const loop = async () => {
                if (paused) {
                    console.log('PAUSE RECOGNIZED')
                    return
                }
                MCTS(root, iterations)
                const data = JSON.stringify(serialize_nodes(all_nodes))
                console.log(Object.keys(all_nodes).length, duplicate_nodes, data.length)
                save_to_file(data, 'mcts_'+ ++last_saved_file_code +'.json')
                console.log('Ready')
                if (success) {
                    console.log('SUCCESS')
                    return
                }
                setTimeout(loop, 0)
            }
            loop()
        }

        // create PAUSE link
        const pause_link = document.createElement('a')
        pause_link.href = '#'
        pause_link.innerText = 'PAUSE'
        links.appendChild(pause_link)
        pause_link.onclick = () => {
            paused = true
            console.log('PAUSED')
        }

        // create board on page
        const board = document.createElement('div')
        board.style = 'display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;'
        board.id = 'board'
        document.body.appendChild(board)
    }

    const pretty_print_inventory = (inventory, growing_inventory = {}) => {
        const pretty_inventory = {}
        const pretty_growing = {}
        let board = 'ðŸ”ƒ' + (inventory['ðŸ”ƒ'] || '') + ' ðŸ‘‘' + (inventory['ðŸ‘‘'] || '') + ' ðŸ’€' + (inventory['ðŸ’€'] || '')
        + '\nâ¹' + (inventory['â¹'] || '') + ': '
        
        const board_items = [
            'ðŸŸ©', 'ðŸŸ¨', 'ðŸŸ§', 'ðŸŸ¦', 'ðŸŒ³', 'ðŸ—»', 'â›°', 'â˜˜', 'ðŸ€', 'ðŸ•³', 'ðŸŸ¤',
            'ðŸ', 'ðŸ¥…', 'ðŸºâš™', 'ðŸ”¥âš™', 'ðŸ¥«âš™', 'ðŸ§€âš™', 'ðŸ§µâš™', 'ðŸ§‚âš™', 'âž•', 'ðŸŒ±âš™', 'ðŸš¿âš™', 'ðŸ¤–', 'ðŸš§', // 'â¹',
            'ðŸ„', 'ðŸ”', 'ðŸ‘', 'ðŸ–'
        ]
        Object.keys(inventory).forEach((key) => {
            // if string matches start of another string
            const match = board_items.find((item) => key.startsWith(item) && !key.includes('ðŸ’³'))
            if (match)
                pretty_inventory[key] = inventory[key]
        })
        Object.keys(pretty_inventory).forEach((key) => {
            if (pretty_inventory[key] > 0)
                board += key + (pretty_inventory[key] || '') + '  '
        })

        board += '\nðŸŒž' + (inventory['ðŸŒž'] || '') + ': '

        Object.keys(growing_inventory).forEach((key) => {
            const match = board_items.find((item) => key.startsWith(item) && !key.includes('ðŸ’³'))
            if (match)
                pretty_growing[key] = inventory[key]
        })
        Object.keys(pretty_growing).forEach((key) => {
            if (pretty_growing[key] > 0)
                board += key + (pretty_growing[key] || '') + '  '
        })

        board += '\nðŸ›’' + (inventory['ðŸ’³'] || '') + ': '

        const shop = {}
        Object.keys(inventory).forEach((key) => {
            if (key.includes('ðŸ’³'))
                shop[key] = inventory[key]
        })
        Object.keys(shop).forEach((key) => {
            if (shop[key] > 0)
                board += key + (shop[key] || '') + '  '
        })

        board += '\nðŸ’§' + (inventory['ðŸ’§'] || '') + ': '
        const tools = {}
        const tool_items = [
            'ðŸ”°', 'â™ ', 'ðŸª“', 'â›', 'ðŸš¿', 'ðŸŽ£', 'ðŸ”¨'
        ]
        Object.keys(inventory).forEach((key) => {
            const match = tool_items.find((item) => key.startsWith(item))
            if (match)
                tools[key] = inventory[key]
        })
        Object.keys(tools).forEach((key) => {
            if (tools[key] > 0)
                board += key + (tools[key] || '') + '  '
        })


        board += '\nðŸ’°' + (inventory['ðŸ’°'] || '') + ': '
        const backpack = {}
        const excludes = ['â¹', 'ðŸŒž', 'ðŸ’§', 'ðŸ›’', 'ðŸ’°']
        Object.keys(inventory).forEach((key) => {
            const is_board_item = board_items.find((item) => key.startsWith(item))
            const is_tool = tool_items.find((item) => key.startsWith(item))
            if (!is_board_item && !is_tool && !key in excludes && !key.includes('ðŸ’³'))
                backpack[key] = inventory[key]
        })
        Object.keys(backpack).forEach((key) => {
            if (backpack[key] > 0)
                board += key + (backpack[key] || '') + '  '
        })
        

        // update board on page
        const board_element = document.getElementById('board')
        board_element.innerText = board

        console.log(board)
    }






    // MAIN LOOP
    //naive_loop()

    // MCTS
    load_controls()

    // ReactDOM.render(<Farm />, document.getElementById('root'))
  </script>

  <div id='root'></div>

</body>

</html>